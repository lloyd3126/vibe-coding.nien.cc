<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <link rel="apple-touch-icon" sizes="180x180" href="../../static/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../static/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../static/favicon_io/favicon-16x16.png">
    <link rel="manifest" href="../../static/favicon_io/site.webmanifest">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini 圖片生成器</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@100..900&family=Noto+Sans+SC:wght@100..900&family=Noto+Sans+TC:wght@100..900&family=Noto+Sans:ital,wght@0,100..900;1,100..900&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --mobile-image-height: 100vw;
            /* 預設為正方形，會透過 JavaScript 動態調整 */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans TC', 'Noto Sans SC', 'Noto Sans', 'Noto Sans JP', Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .left-panel {
            width: 50%;
            padding: 20px;
            background-color: #ffffff;
            overflow-y: auto;
            border-right: 2px solid #dee2e6;
            scrollbar-gutter: stable;
        }

        .right-panel {
            width: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f8f9fa;
            position: relative;
            overflow: hidden;
        }

        .right-panel.history-mode {
            align-items: flex-start;
            justify-content: flex-start;
            padding: 30px 20px;
            /* 增加頂部內邊距，改善視覺效果 */
        }

        h1 {
            margin-top: 25px;
            margin-bottom: 30px;
            color: #333;
            text-align: center;
        }

        section {
            margin-bottom: 20px;
        }

        /* 按鈕容器的彈性佈局 */
        section:has(button) {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }

        input,
        textarea,
        select {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            box-sizing: border-box;
            font-size: 14px;
        }

        /* 禁用狀態樣式 */
        input:disabled,
        textarea:disabled,
        select:disabled {
            background-color: #f5f5f5;
            color: #999;
            cursor: not-allowed;
            border-color: #ccc;
            opacity: 0.6;
        }

        /* 歷史模式下左側面板的禁用樣式 */
        .left-panel.history-mode input,
        .left-panel.history-mode textarea,
        .left-panel.history-mode select {
            background-color: #f5f5f5;
            color: #999;
            cursor: not-allowed;
            border-color: #ccc;
            opacity: 0.6;
        }

        .left-panel.history-mode label {
            color: #999;
        }

        textarea {
            resize: none;
            min-height: 120px;
            overflow: hidden;
            white-space: pre;
            overflow-x: auto;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.3s ease;
            flex: 1;
            min-width: 120px;
        }

        #generateBtn {
            background-color: #000000;
            color: white;
        }

        #generateBtn:hover {
            background-color: #333333;
        }

        #generateBtn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        #enhancePromptBtn {
            background-color: #000000;
            color: white;
        }

        #enhancePromptBtn:hover {
            background-color: #333333;
        }

        #enhancePromptBtn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        #clearBtn {
            background-color: #000000;
            color: white;
        }

        #clearBtn:hover {
            background-color: #333333;
        }

        #clearBtn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        #downloadBtn {
            background-color: #000000;
            color: white;
        }

        #downloadBtn:hover {
            background-color: #333333;
        }

        #downloadBtn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        #historyBtn {
            background-color: #000000;
            color: white;
        }

        #historyBtn:hover {
            background-color: #333333;
        }

        #historyBtn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        /* 左側面板滾動條樣式 */
        .left-panel {
            scrollbar-width: thin;
            scrollbar-color: #c1c1c1 #f8f9fa;
        }

        .left-panel::-webkit-scrollbar {
            width: 8px;
        }

        .left-panel::-webkit-scrollbar-track {
            background: #f8f9fa;
            border-radius: 4px;
        }

        .left-panel::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        .left-panel::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }

        /* 歷史網格樣式 - 固定列數，自然間距，垂直捲動 */
        #historyGrid {
            display: none;
            grid-template-columns: repeat(3, 150px);
            /* 固定3列，每列150px */
            gap: 20px;
            /* 固定間距 */
            justify-content: start;
            /* 左對齊，避免拉伸 */
            width: 100%;
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #dee2e6;
            box-sizing: border-box;
            position: absolute;
            top: 0;
            left: 0;
            padding: 20px;
            /* 自定義滾動條樣式 */
            scrollbar-width: thin;
            scrollbar-color: #c1c1c1 #f8f9fa;
        }

        /* WebKit 瀏覽器的滾動條樣式 */
        #historyGrid::-webkit-scrollbar {
            width: 8px;
        }

        #historyGrid::-webkit-scrollbar-track {
            background: #f8f9fa;
            border-radius: 4px;
        }

        #historyGrid::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        #historyGrid::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }

        #historyGrid.active {
            display: grid;
        }

        /* 當右側面板處於歷史模式時，調整網格樣式 */
        .right-panel.history-mode #historyGrid {
            position: relative;
            height: calc(100vh - 60px);
            /* 減去上下 padding (30px * 2) */
            border: none;
            border-radius: 0;
            background-color: transparent;
            /* 在歷史模式下可能需要調整列數以適應更大空間 */
            grid-template-columns: repeat(4, 150px);
            /* 歷史模式下4列 */
            gap: 25px;
            /* 稍微增加間距 */
            justify-content: start;
            /* 左對齊，保持一致性 */
            padding: 0;
            /* 移除內部 padding，因為外層已有 */
        }

        .thumbnail-item {
            position: relative;
            width: 150px;
            height: 150px;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            /* 確保縮圖不會被拉伸 */
            flex-shrink: 0;
        }

        .thumbnail-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .thumbnail-item.selected {
            border-color: #2196F3;
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.3);
        }

        .thumbnail-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .thumbnail-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f5f5f5;
            color: #999;
            font-size: 12px;
        }

        .thumbnail-tooltip {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            color: white;
            padding: 8px;
            font-size: 11px;
            opacity: 0;
            transition: opacity 0.3s ease;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .thumbnail-item:hover .thumbnail-tooltip {
            opacity: 1;
        }

        /* 載入更多按鈕 - 適應固定列數網格 */
        .load-more-container {
            grid-column: span 3;
            /* 默認跨越3列 */
            text-align: center;
            padding: 20px;
            display: none;
            margin-top: 10px;
        }

        /* 歷史模式下跨越4列 */
        .right-panel.history-mode .load-more-container {
            grid-column: span 4;
        }

        .load-more-container.active {
            display: block;
        }

        #loadMoreBtn {
            background-color: #000000;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        #loadMoreBtn:hover {
            background-color: #333333;
        }

        #loadMoreBtn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        #status {
            padding: 12px;
            border-radius: 6px;
            margin: 15px 0;
            min-height: 20px;
            font-weight: 500;
            display: none;
            /* 預設隱藏 */
        }

        #status:not(:empty) {
            display: block;
            /* 有內容時顯示 */
        }

        .status-error {
            background-color: #ffebee;
            color: #c62828;
            border: 1px solid #ef5350;
        }

        .status-success {
            background-color: #e8f5e8;
            color: #2e7d32;
            border: 1px solid #4caf50;
        }

        .status-loading {
            background-color: #fff3e0;
            color: #ef6c00;
            border: 1px solid #ff9800;
        }

        .status-info {
            background-color: #e3f2fd;
            color: #1565c0;
            border: 1px solid #2196f3;
        }

        #imageContainer {
            max-width: 512px;
            max-height: 512px;
            width: 512px;
            height: 512px;
            border: 2px dashed #ccc;
            background-color: #ffffff;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            position: relative;
            z-index: 1;
        }

        /* 當 imageContainer 有背景圖片時的點擊樣式 */
        #imageContainer[style*="background-image"] {
            cursor: pointer;
        }

        #imageContainer[style*="background-image"]:hover {
            transform: scale(1.02);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
        }

        #imageContainer[style*="background-image"]:active {
            transform: scale(0.98);
        }

        /* 點擊提示浮動文字 */
        #imageContainer[style*="background-image"]::after {
            content: attr(data-click-hint);
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            white-space: nowrap;
            z-index: 10;
        }

        #imageContainer[style*="background-image"]:hover::after {
            opacity: 1;
        }

        #imageContainer.hidden {
            display: none;
        }

        #imageContainer p {
            text-align: center;
            margin: 0;
            color: #666;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
        }

        /* Loading spinner styles */
        .loader {
            border: 16px solid #f0f0f0;
            border-radius: 50%;
            border-top: 16px solid #000000;
            width: 120px;
            height: 120px;
            -webkit-animation: spin 2s linear infinite;
            /* Safari */
            animation: spin 2s linear infinite;
            margin: auto;
        }

        /* Safari */
        @-webkit-keyframes spin {
            0% {
                -webkit-transform: rotate(0deg);
            }

            100% {
                -webkit-transform: rotate(360deg);
            }
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            gap: 20px;
            position: relative;
            z-index: 2;
        }

        /* 當 imageContainer 有背景圖片且處於 loading 狀態時的半透明背景 */
        #imageContainer[style*="background-image"] .loading-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            z-index: -1;
        }

        .loading-text {
            color: #666;
            font-size: 16px;
            font-weight: 500;
        }

        /* 當有背景圖片時，讓 loading 文字更清楚可見 */
        #imageContainer[style*="background-image"] .loading-text {
            color: #ffffff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        /* 當有背景圖片時，確保 spinner 也清楚可見 */
        #imageContainer[style*="background-image"] .loader {
            border: 16px solid rgba(240, 240, 240, 0.3);
            border-top: 16px solid #ffffff;
        }

        /* 手機版響應式設計 - 480px 斷點 */
        @media (max-width: 480px) {
            body {
                overflow-x: hidden;
                /* 防止水平滾動 */
                overflow-y: auto;
                /* 允許垂直滾動 */
            }

            .container {
                flex-direction: column !important;
                height: auto !important;
                /* 改為自動高度，允許滾動 */
                min-height: 100vh !important;
                /* 最小高度為視窗高度 */
                padding: 10px !important;
                gap: 15px !important;
                overflow: visible !important;
                /* 允許內容溢出以便滾動 */
            }

            .left-panel {
                width: 100% !important;
                height: auto !important;
                order: 1;
                padding: 15px !important;
                flex-shrink: 0;
                /* 防止收縮 */
            }

            .right-panel {
                width: 100% !important;
                height: auto !important;
                /* 改為自動高度 */
                min-height: auto !important;
                /* 移除最小高度，避免不必要的空白 */
                order: 2;
                padding: 15px !important;
                flex-shrink: 0;
                /* 防止收縮 */
                overflow-y: visible !important;
                /* 改為可見，避免內容被裁切 */
                display: flex !important;
                /* 確保彈性佈局 */
                flex-direction: column !important;
                /* 垂直排列 */
            }

            /* 按鈕群組垂直排列 */
            .controls {
                flex-direction: column !important;
                gap: 10px !important;
                margin-top: 15px !important;
            }

            .controls button {
                width: 100% !important;
                height: 44px !important;
                /* 觸控友好的按鈕高度 */
                font-size: 16px !important;
                padding: 0 15px !important;
            }

            /* 表單元素調整 */
            .form-group {
                margin-bottom: 15px !important;
            }

            .form-group label {
                font-size: 14px !important;
                margin-bottom: 5px !important;
            }

            .form-group input,
            .form-group select,
            .form-group textarea {
                width: 95% !important;
                font-size: 16px !important;
                padding: 10px !important;
            }

            /* 歷史記錄網格 - 單列布局 */
            #historyGrid {
                grid-template-columns: 1fr !important;
                gap: 15px !important;
                padding: 0 !important;
                /* 移除 padding，避免圖片被裁切 */
                max-height: none !important;
                /* 移除最大高度限制 */
                overflow-y: visible !important;
                /* 允許內容正常顯示 */
                position: relative !important;
                /* 改為相對定位，避免裁切 */
                height: auto !important;
                /* 高度自動調整 */
                border: none !important;
                /* 移除邊框 */
                background-color: transparent !important;
                /* 透明背景 */
            }

            /* 手機版歷史模式下的網格高度調整 */
            .right-panel.history-mode #historyGrid {
                height: auto !important;
                min-height: auto !important;
                /* 移除最小高度限制 */
            }

            /* 手機版縮圖樣式 - 寬度 100%，高度自動等比例縮放 */
            .thumbnail-item {
                width: 100% !important;
                height: auto !important;
                /* 高度自動，讓圖片保持原比例 */
                max-width: 100% !important;
                margin: 0 auto !important;
                /* 移除固定的 aspect-ratio，讓圖片保持原始比例 */
            }

            .thumbnail-image {
                width: 100% !important;
                height: 100% !important;
                /* 填滿容器 */
                object-fit: contain !important;
                /* 保持圖片比例並完整顯示在容器內 */
                border-radius: 8px !important;
                /* 確保圖片也有圓角 */
            }

            /* 載入更多按鈕 */
            #loadMoreBtn {
                width: 100% !important;
                margin: 0 !important;
                display: block !important;
                height: 44px !important;
                font-size: 16px !important;
                padding: 0 !important;
            }

            /* 手機版載入更多按鈕容器調整 */
            .load-more-container {
                grid-column: span 1 !important;
                /* 手機版單列模式下跨越1列 */
                margin: 0 !important;
                padding: 0 !important;
            }

            /* 狀態訊息 */
            #status {
                font-size: 14px !important;
                padding: 8px 12px !important;
                margin: 10px 0 !important;
            }

            /* 圖片容器調整 - 使用動態高度 */
            #imageContainer {
                margin: 0 auto !important;
                width: 100% !important;
                height: var(--mobile-image-height) !important;
                /* 使用動態計算的高度 */
                max-width: 100% !important;
                min-height: 200px !important;
                /* 設定最小高度避免太小 */
                max-height: calc(100vh - 100px) !important;
                /* 限制最大高度不超過視窗高度減去一些邊距 */
            }

            /* 確保圖片在容器內正確顯示 */
            #imageContainer img {
                width: 100% !important;
                height: 100% !important;
                object-fit: contain !important;
                max-height: 90vw !important;
                /* 圖片也不超過容器大小 */
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- 左側面板 - 輸入區域 -->
        <div class="left-panel">
            <h1>Gemini AI 圖片生成器</h1>

            <!-- 主要內容區域 -->
            <main>
                <!-- 介面語言選擇區域 -->
                <section>
                    <label for="uiLanguage">介面語言</label>
                    <select id="uiLanguage">
                        <option value="zh-tw">繁體中文</option>
                        <option value="zh-cn">简体中文</option>
                        <option value="en">English</option>
                        <option value="ja">日本語</option>
                    </select>
                </section>

                <!-- API Key 輸入區域 -->
                <section>
                    <label for="apiKey">Gemini API Key</label>
                    <input type="password" id="apiKey">
                </section>

                <!-- 圖片尺寸選擇區域 -->
                <section>
                    <label for="aspectRatio">圖片尺寸</label>
                    <select id="aspectRatio">
                        <option value="1:1" selected>1:1</option>
                        <option value="9:16">9:16</option>
                        <option value="16:9">16:9</option>
                        <option value="4:3">4:3</option>
                        <option value="3:4">3:4</option>
                    </select>
                </section>

                <!-- AI 模型選擇區域 -->
                <section>
                    <label for="modelSelect">模型選擇</label>
                    <select id="modelSelect">
                        <option value="models/imagen-3.0-generate-002">Imagen 3.0</option>
                        <option value="models/imagen-4.0-ultra-generate-preview-06-06">Imagen 4.0 Ultra</option>
                        <option value="models/imagen-4.0-generate-preview-06-06" selected>Imagen 4.0</option>
                    </select>
                </section>

                <!-- 提示詞輸入區域 -->
                <section>
                    <label for="prompt">想畫什麼</label>
                    <textarea id="prompt" rows="6" cols="50"></textarea>
                </section>

                <!-- 自動翻譯選項區域 -->
                <section>
                    <label for="autoTranslate">生成圖片前是否將提示詞翻譯為英文</label>
                    <select id="autoTranslate">
                        <option value="no">否</option>
                        <option value="yes">是</option>
                    </select>
                </section>

                <!-- 控制按鈕 -->
                <section>
                    <button id="enhancePromptBtn" disabled>改善提示</button>
                    <button id="generateBtn" disabled>生成圖片</button>
                    <button id="downloadBtn" disabled>下載圖片</button>
                    <button id="clearBtn" disabled>清除圖片</button>
                    <button id="historyBtn">歷史紀錄</button>
                </section>

                <!-- 狀態顯示區域 -->
                <section>
                    <div id="status"></div>
                </section>
            </main>
        </div>

        <!-- 右側面板 - 圖片顯示區域 -->
        <div class="right-panel" id="rightPanel">
            <div id="imageContainer">
                <p></p>
            </div>
        </div>
    </div>

    <script>
        // UI 多語言資源常數
        const UI_LANG_RESOURCES = {
            'zh-tw': {
                title: 'Gemini 圖片生成器',
                pageTitle: 'Gemini 圖片生成器',
                labels: {
                    apiKey: 'Gemini API Key',
                    aspectRatio: '圖片尺寸',
                    modelSelect: '模型選擇',
                    prompt: '想畫什麼',
                    autoTranslate: '生成圖片前是否將提示詞翻譯為英文',
                    uiLanguage: '介面語言',
                    languageNameEn: '英文',
                    languageNameZhTw: '繁體中文',
                    languageNameZhCn: '簡體中文',
                    languageNameJp: '日文'
                },
                buttons: {
                    enhancePrompt: '改善提示',
                    generateImage: '生成圖片',
                    downloadImage: '下載圖片',
                    clearImage: '清除圖片',
                    history: '歷史紀錄',
                    loadMore: '載入更多'
                },
                options: {
                    yes: '是',
                    no: '否',
                    uiLanguages: {
                        'zh-tw': '繁體中文',
                        'zh-cn': '簡體中文',
                        'en': 'English',
                        'ja': '日本語'
                    }
                },
                placeholders: {
                    apiKey: '請輸入您的 Gemini API Key',
                    prompt: '請描述您想要生成的圖片...',
                    defaultImageText: '生成的圖片將顯示在這裡'
                },
                messages: {
                    apiKeyRequired: '請輸入 Gemini API Key',
                    promptRequired: '請輸入想畫什麼',
                    invalidApiKey: 'API Key 無效，請檢查您的 Gemini API Key',
                    rateLimit: 'API 使用頻率過高，請稍後再試',
                    badRequest: '請求參數錯誤，請檢查輸入內容',
                    noImageToDownload: '沒有可下載的圖片',
                    invalidResponse: 'API 響應格式不正確或沒有生成圖片',
                    promptEnhanceRequired: '請輸入提示詞以進行改善',
                    promptEnhanceFailed: '提示詞改善失敗，請稍後再試',
                    promptEnhanceInvalidResponse: '提示詞改善回應格式不正確',
                    translationFailed: '提示詞翻譯失敗，請稍後再試',
                    translationInvalidResponse: '翻譯回應格式不正確',
                    translationInputInvalid: '翻譯輸入內容格式不正確',
                    translationOutputInvalid: '翻譯輸出結果格式不正確',
                    networkError: '網路連線錯誤，請檢查網路狀態',
                    timeoutError: '請求逾時，請稍後再試',
                    loading: '處理中...',
                    generating: '生成中...',
                    enhancing: '改善中...',
                    translating: '翻譯中...',
                    languageChanged: '語言已切換',
                    languageChangeFailed: '語言切換失敗',
                    appInitFailed: '應用程式初始化失敗',
                    historyToggleFailed: '切換歷史模式失敗',
                    historyLoadFailed: '載入歷史記錄失敗',
                    imageLoadFailed: '載入圖片失敗',
                    loadMoreFailed: '載入更多記錄失敗',
                    noHistory: '沒有歷史記錄',
                    historyLoadSuccess: '歷史記錄載入成功！',
                    backToImageDisplay: '已返回圖片顯示',
                    loadingImage: '載入圖片...',
                    imageLoadSuccess: '圖片載入成功！',
                    enhancingPrompt: '正在改善提示詞，請稍候...',
                    languageMismatchRetry: '語言不符，正在重試...',
                    retrying: '正在重試...',
                    promptEnhanceSuccess: '提示詞改善成功！',
                    imageGenerating: '正在生成圖片，請稍候...',
                    imageGenerationInProgress: '圖片生成進行中，請稍候',
                    confirmRetryEnhance: '改善提示詞失敗：{0}\n\n是否要重試？',
                    imageGenerationSuccess: '圖片生成成功！',
                    translatingPrompt: '正在翻譯提示詞...',
                    downloadSuccess: '圖片下載成功！',
                    clearImageError: '清除圖片時發生錯誤',
                    imageClearedWithHistory: '圖片及歷史記錄已清除',
                    imageCleared: '圖片已清除',
                    translationFailedWithError: '翻譯失敗：{0}',
                    confirmRetryTranslation: '翻譯失敗：{0}\n\n是否要重試翻譯？',
                    base64ConversionError: 'Base64 轉換失敗',
                    translationTimeout: '翻譯請求超時，請稍後再試',
                    networkConnectionError: '網路連接失敗，請檢查網路連接',
                    userCancelledTranslation: '用戶取消翻譯重試',
                    imageGenerationInProgressError: '圖片生成進行中，請稍候',
                    historyRecordNotFound: '找不到指定的歷史記錄',
                    confirmClearImageWithHistory: '確定要清除當前圖片嗎？\n\n注意：這將同時從歷史紀錄中刪除該圖片，此操作無法復原。',
                    confirmClearImage: '確定要清除當前圖片嗎？',
                    loadMoreLoading: '載入中...',
                    confirmLanguageMismatch: '改善後的提示詞語言可能不符合您選擇的「{0}」，是否要重試？',
                    thumbnailLoadFailed: '載入失敗',
                    imageOpenInNewTab: '點擊在新分頁中開啟圖片',
                    imageOpenFailed: '無法開啟圖片，請稍後再試'
                }
            },
            'en': {
                title: 'Gemini Image Generator',
                pageTitle: 'Gemini Image Generator',
                labels: {
                    apiKey: 'Gemini API Key',
                    aspectRatio: 'Image Size',
                    modelSelect: 'Model Selection',
                    prompt: 'What to draw',
                    autoTranslate: 'Translate prompt to English before generation',
                    uiLanguage: 'Interface Language',
                    languageNameEn: 'English',
                    languageNameZhTw: 'Traditional Chinese',
                    languageNameZhCn: 'Simplified Chinese',
                    languageNameJp: 'Japanese'
                },
                buttons: {
                    enhancePrompt: 'Enhance Prompt',
                    generateImage: 'Generate Image',
                    downloadImage: 'Download Image',
                    clearImage: 'Clear Image',
                    history: 'History',
                    loadMore: 'Load More'
                },
                options: {
                    yes: 'Yes',
                    no: 'No',
                    uiLanguages: {
                        'zh-tw': '繁體中文',
                        'zh-cn': '简体中文',
                        'en': 'English',
                        'ja': '日本語'
                    }
                },
                placeholders: {
                    apiKey: 'Please enter your Gemini API Key',
                    prompt: 'Describe the image you want to generate...',
                    defaultImageText: 'Generated image will be displayed here'
                },
                messages: {
                    apiKeyRequired: 'Please enter Gemini API Key',
                    promptRequired: 'Please enter what to draw',
                    invalidApiKey: 'Invalid API Key, please check your Gemini API Key',
                    rateLimit: 'API rate limit exceeded, please try again later',
                    badRequest: 'Request parameter error, please check input content',
                    noImageToDownload: 'No image to download',
                    invalidResponse: 'Invalid API response format or no image generated',
                    promptEnhanceRequired: 'Please enter prompt for enhancement',
                    promptEnhanceFailed: 'Prompt enhancement failed, please try again later',
                    promptEnhanceInvalidResponse: 'Invalid prompt enhancement response format',
                    translationFailed: 'Prompt translation failed, please try again later',
                    translationInvalidResponse: 'Invalid translation response format',
                    translationInputInvalid: 'Invalid translation input format',
                    translationOutputInvalid: 'Invalid translation output format',
                    networkError: 'Network connection error, please check network status',
                    timeoutError: 'Request timeout, please try again later',
                    loading: 'Processing...',
                    generating: 'Generating...',
                    enhancing: 'Enhancing...',
                    translating: 'Translating...',
                    languageChanged: 'Language switched',
                    languageChangeFailed: 'Language switch failed',
                    appInitFailed: 'Application initialization failed',
                    historyToggleFailed: 'History mode toggle failed',
                    historyLoadFailed: 'Failed to load history',
                    imageLoadFailed: 'Failed to load image',
                    loadMoreFailed: 'Failed to load more records',
                    noHistory: 'No history records',
                    historyLoadSuccess: 'History loaded successfully!',
                    backToImageDisplay: 'Returned to image display',
                    loadingImage: 'Loading image...',
                    imageLoadSuccess: 'Image loaded successfully!',
                    enhancingPrompt: 'Enhancing prompt, please wait...',
                    languageMismatchRetry: 'Language mismatch, retrying...',
                    retrying: 'Retrying...',
                    promptEnhanceSuccess: 'Prompt enhanced successfully!',
                    imageGenerating: 'Generating image, please wait...',
                    imageGenerationInProgress: 'Image generation in progress, please wait',
                    confirmRetryEnhance: 'Prompt enhancement failed: {0}\n\nWould you like to retry?',
                    imageGenerationSuccess: 'Image generated successfully!',
                    translatingPrompt: 'Translating prompt...',
                    downloadSuccess: 'Image downloaded successfully!',
                    clearImageError: 'Error occurred while clearing image',
                    imageClearedWithHistory: 'Image and history record cleared',
                    imageCleared: 'Image cleared',
                    translationFailedWithError: 'Translation failed: {0}',
                    confirmRetryTranslation: 'Translation failed: {0}\n\nWould you like to retry translation?',
                    base64ConversionError: 'Base64 conversion failed',
                    translationTimeout: 'Translation request timeout, please try again later',
                    networkConnectionError: 'Network connection failed, please check network connection',
                    userCancelledTranslation: 'User cancelled translation retry',
                    imageGenerationInProgressError: 'Image generation in progress, please wait',
                    historyRecordNotFound: 'Specified history record not found',
                    confirmClearImageWithHistory: 'Are you sure you want to clear the current image?\n\nNote: This will also delete the image from history records. This action cannot be undone.',
                    confirmClearImage: 'Are you sure you want to clear the current image?',
                    loadMoreLoading: 'Loading...',
                    confirmLanguageMismatch: 'The enhanced prompt language may not match your selected "{0}". Would you like to retry?',
                    thumbnailLoadFailed: 'Load Failed',
                    imageOpenInNewTab: 'Click to open image in new tab',
                    imageOpenFailed: 'Failed to open image, please try again later'
                }
            },
            'ja': {
                title: 'Gemini 画像生成器',
                pageTitle: 'Gemini 画像生成器',
                labels: {
                    apiKey: 'Gemini API Key',
                    aspectRatio: '画像サイズ',
                    modelSelect: 'モデル選択',
                    prompt: '何を描きますか',
                    autoTranslate: '生成前にプロンプトを英語に翻訳する',
                    uiLanguage: 'インターフェース言語',
                    languageNameEn: '英語',
                    languageNameZhTw: '繁体中国語',
                    languageNameZhCn: '簡体中国語',
                    languageNameJp: '日本語'
                },
                buttons: {
                    enhancePrompt: 'プロンプト改善',
                    generateImage: '画像生成',
                    downloadImage: '画像ダウンロード',
                    clearImage: '画像クリア',
                    history: '履歴',
                    loadMore: 'さらに読み込む'
                },
                options: {
                    yes: 'はい',
                    no: 'いいえ',
                    uiLanguages: {
                        'zh-tw': '繁體中文',
                        'zh-cn': '简体中文',
                        'en': 'English',
                        'ja': '日本語'
                    }
                },
                placeholders: {
                    apiKey: 'Gemini API Keyを入力してください',
                    prompt: '生成したい画像を説明してください...',
                    defaultImageText: '生成された画像がここに表示されます'
                },
                messages: {
                    apiKeyRequired: 'Gemini API Keyを入力してください',
                    promptRequired: '何を描くか入力してください',
                    invalidApiKey: '無効なAPI Key、Gemini API Keyを確認してください',
                    rateLimit: 'API使用頻度が高すぎます、しばらくしてからお試しください',
                    badRequest: 'リクエストパラメータエラー、入力内容を確認してください',
                    noImageToDownload: 'ダウンロードする画像がありません',
                    invalidResponse: 'API応答形式が正しくないか、画像が生成されませんでした',
                    promptEnhanceRequired: '改善するプロンプトを入力してください',
                    promptEnhanceFailed: 'プロンプト改善が失敗しました、しばらくしてからお試しください',
                    promptEnhanceInvalidResponse: 'プロンプト改善応答形式が正しくありません',
                    translationFailed: 'プロンプト翻訳が失敗しました、しばらくしてからお試しください',
                    translationInvalidResponse: '翻訳応答形式が正しくありません',
                    translationInputInvalid: '翻訳入力内容の形式が正しくありません',
                    translationOutputInvalid: '翻訳出力結果の形式が正しくありません',
                    networkError: 'ネットワーク接続エラー、ネットワーク状態を確認してください',
                    timeoutError: 'リクエストタイムアウト、しばらくしてからお試しください',
                    loading: '処理中...',
                    generating: '生成中...',
                    enhancing: '改善中...',
                    translating: '翻訳中...',
                    languageChanged: '言語が切り替わりました',
                    languageChangeFailed: '言語切り替えに失敗しました',
                    appInitFailed: 'アプリケーションの初期化に失敗しました',
                    historyToggleFailed: '履歴モードの切り替えに失敗しました',
                    historyLoadFailed: '履歴の読み込みに失敗しました',
                    imageLoadFailed: '画像の読み込みに失敗しました',
                    loadMoreFailed: 'さらに記録を読み込むのに失敗しました',
                    noHistory: '履歴記録がありません',
                    historyLoadSuccess: '履歴が正常に読み込まれました！',
                    backToImageDisplay: '画像表示に戻りました',
                    loadingImage: '画像を読み込み中...',
                    imageLoadSuccess: '画像が正常に読み込まれました！',
                    enhancingPrompt: 'プロンプトを改善中、お待ちください...',
                    languageMismatchRetry: '言語が一致しません、再試行中...',
                    retrying: '再試行中...',
                    promptEnhanceSuccess: 'プロンプトが正常に改善されました！',
                    imageGenerating: '画像を生成中、お待ちください...',
                    imageGenerationInProgress: '画像生成が進行中です、お待ちください',
                    confirmRetryEnhance: 'プロンプト改善に失敗しました：{0}\n\n再試行しますか？',
                    imageGenerationSuccess: '画像が正常に生成されました！',
                    translatingPrompt: 'プロンプトを翻訳中...',
                    downloadSuccess: '画像のダウンロードが完了しました！',
                    clearImageError: '画像のクリア時にエラーが発生しました',
                    imageClearedWithHistory: '画像と履歴記録がクリアされました',
                    imageCleared: '画像がクリアされました',
                    translationFailedWithError: '翻訳に失敗しました：{0}',
                    confirmRetryTranslation: '翻訳に失敗しました：{0}\n\n翻訳を再試行しますか？',
                    base64ConversionError: 'Base64変換に失敗しました',
                    translationTimeout: '翻訳リクエストがタイムアウトしました、しばらくしてからお試しください',
                    networkConnectionError: 'ネットワーク接続に失敗しました、ネットワーク接続を確認してください',
                    userCancelledTranslation: 'ユーザーが翻訳の再試行をキャンセルしました',
                    imageGenerationInProgressError: '画像生成が進行中です、お待ちください',
                    historyRecordNotFound: '指定された履歴記録が見つかりません',
                    confirmClearImageWithHistory: '現在の画像をクリアしてもよろしいですか？\n\n注意：これにより履歴記録からも画像が削除されます。この操作は元に戻せません。',
                    confirmClearImage: '現在の画像をクリアしてもよろしいですか？',
                    loadMoreLoading: '読み込み中...',
                    confirmLanguageMismatch: '改善されたプロンプトの言語が選択した「{0}」と一致しない可能性があります。再試行しますか？',
                    thumbnailLoadFailed: '読み込み失敗',
                    imageOpenInNewTab: 'クリックして新しいタブで画像を開く',
                    imageOpenFailed: '画像を開けませんでした。しばらくしてからお試しください'
                }
            },
            'zh-cn': {
                title: 'Gemini 图片生成器',
                pageTitle: 'Gemini 图片生成器',
                labels: {
                    apiKey: 'Gemini API Key',
                    aspectRatio: '图片尺寸',
                    modelSelect: '模型选择',
                    prompt: '想画什么',
                    autoTranslate: '生成图片前是否将提示词翻译为英文',
                    uiLanguage: '界面语言',
                    languageNameEn: '英文',
                    languageNameZhTw: '繁体中文',
                    languageNameJp: '日文',
                    languageNameZhCn: '简体中文'
                },
                buttons: {
                    enhancePrompt: '改善提示',
                    generateImage: '生成图片',
                    downloadImage: '下载图片',
                    clearImage: '清除图片',
                    history: '历史记录',
                    loadMore: '加载更多'
                },
                options: {
                    yes: '是',
                    no: '否',
                    uiLanguages: {
                        'zh-tw': '繁體中文',
                        'zh-cn': '简体中文',
                        'en': 'English',
                        'ja': '日本語'
                    }
                },
                placeholders: {
                    apiKey: '请输入您的 Gemini API Key',
                    prompt: '请描述您想要生成的图片...',
                    defaultImageText: '生成的图片将显示在这里'
                },
                messages: {
                    apiKeyRequired: '请输入 Gemini API Key',
                    promptRequired: '请输入想画什么',
                    invalidApiKey: 'API Key 无效，请检查您的 Gemini API Key',
                    rateLimit: 'API 使用频率过高，请稍后再试',
                    badRequest: '请求参数错误，请检查输入内容',
                    noImageToDownload: '没有可下载的图片',
                    invalidResponse: 'API 响应格式不正确或没有生成图片',
                    promptEnhanceRequired: '请输入提示词以进行改善',
                    promptEnhanceFailed: '提示词改善失败，请稍后再试',
                    promptEnhanceInvalidResponse: '提示词改善回应格式不正确',
                    translationFailed: '提示词翻译失败，请稍后再试',
                    translationInvalidResponse: '翻译回应格式不正确',
                    translationInputInvalid: '翻译输入内容格式不正确',
                    translationOutputInvalid: '翻译输出结果格式不正确',
                    networkError: '网络连线错误，请检查网络状态',
                    timeoutError: '请求超时，请稍后再试',
                    loading: '处理中...',
                    generating: '生成中...',
                    enhancing: '改善中...',
                    translating: '翻译中...',
                    languageChanged: '语言已切换',
                    languageChangeFailed: '语言切换失败',
                    appInitFailed: '应用程序初始化失败',
                    historyToggleFailed: '切换历史模式失败',
                    historyLoadFailed: '加载历史记录失败',
                    imageLoadFailed: '加载图片失败',
                    loadMoreFailed: '加载更多记录失败',
                    noHistory: '没有历史记录',
                    historyLoadSuccess: '历史记录加载成功！',
                    backToImageDisplay: '已返回图片显示',
                    loadingImage: '加载图片...',
                    imageLoadSuccess: '图片加载成功！',
                    enhancingPrompt: '正在改善提示词，请稍候...',
                    languageMismatchRetry: '语言不符，正在重试...',
                    retrying: '正在重试...',
                    promptEnhanceSuccess: '提示词改善成功！',
                    imageGenerating: '正在生成图片，请稍候...',
                    imageGenerationInProgress: '图片生成进行中，请稍候',
                    confirmRetryEnhance: '改善提示词失败：{0}\n\n是否要重试？',
                    imageGenerationSuccess: '图片生成成功！',
                    translatingPrompt: '正在翻译提示词...',
                    downloadSuccess: '图片下载成功！',
                    clearImageError: '清除图片时发生错误',
                    imageClearedWithHistory: '图片及历史记录已清除',
                    imageCleared: '图片已清除',
                    translationFailedWithError: '翻译失败：{0}',
                    confirmRetryTranslation: '翻译失败：{0}\n\n是否要重试翻译？',
                    base64ConversionError: 'Base64 转换失败',
                    translationTimeout: '翻译请求超时，请稍后再试',
                    networkConnectionError: '网络连接失败，请检查网络连接',
                    userCancelledTranslation: '用户取消翻译重试',
                    imageGenerationInProgressError: '图片生成进行中，请稍候',
                    historyRecordNotFound: '找不到指定的历史记录',
                    confirmClearImageWithHistory: '确定要清除当前图片吗？\n\n注意：这将同时从历史记录中删除该图片，此操作无法撤销。',
                    confirmClearImage: '确定要清除当前图片吗？',
                    loadMoreLoading: '加载中...',
                    confirmLanguageMismatch: '改善后的提示词语言可能不符合您选择的「{0}」，是否要重试？',
                    thumbnailLoadFailed: '加载失败',
                    imageOpenInNewTab: '点击在新标签页中开启图片',
                    imageOpenFailed: '无法开启图片，请稍后再试'
                }
            }
        };

        // 設定常數
        const CONFIG = {
            API: {
                BASE_URL: 'https://generativelanguage.googleapis.com/v1beta',
                DEFAULT_MODEL: 'models/imagen-4.0-generate-preview-06-06',
                MODELS: {
                    IMAGEN_3: 'models/imagen-3.0-generate-002',
                    IMAGEN_4_ULTRA: 'models/imagen-4.0-ultra-generate-preview-06-06',
                    IMAGEN_4: 'models/imagen-4.0-generate-preview-06-06',
                    GEMINI_2_5_PRO: 'gemini-2.5-pro'
                }
            },
            IMAGE: {
                DEFAULT_ASPECT_RATIO: '1:1',
                MAX_SIZE: 512,
                ASPECT_RATIOS: {
                    SQUARE: '1:1',
                    PORTRAIT_9_16: '9:16',
                    LANDSCAPE_16_9: '16:9',
                    TRADITIONAL_LANDSCAPE: '4:3',
                    TRADITIONAL_PORTRAIT: '3:4'
                }
            },
            STORAGE: {
                API_KEY: 'gemini_api_key',
                ASPECT_RATIO: 'gemini_aspect_ratio',
                MODEL_SELECTION: 'selectedModel',
                LANGUAGE: 'selected_language',
                UI_LANGUAGE: 'selected_ui_language',
                AUTO_TRANSLATE: 'auto_translate_prompt'
            },
            PROMPT_LANGUAGE: {
                // 根據UI語言映射到提示詞語言
                UI_TO_PROMPT_MAPPING: {
                    'zh-tw': 'zh-TW',
                    'zh-cn': 'zh-CN',
                    'en': 'en',
                    'ja': 'jp'
                },
                INSTRUCTIONS: {
                    'en': 'All JSON values must be in en.',
                    'zh-TW': 'All JSON values must be in zh-TW.',
                    'zh-CN': 'All JSON values must be in zh-CN.',
                    'jp': 'All JSON values must be in jp.'
                }
            },
            LANGUAGE: {
                DEFAULT: 'en',
                URL_PARAM: 'prompt_lang'
            },
            UI_LANGUAGE: {
                DEFAULT: 'zh-tw',
                SUPPORTED: ['zh-tw', 'zh-cn', 'en', 'ja'],
                URL_PARAM: 'lang'
            },
            TRANSLATION: {
                INSTRUCTION: 'Translate all JSON values to English while keeping the JSON structure intact.',
                TIMEOUT: 100000 // 100 秒
            },
            TIMEOUTS: {
                STATUS_CLEAR: 3000
            }
        };

        // JSON Schema 模板常數
        const PROMPT_ENHANCEMENT_SCHEMA = {
            "type": "object",
            "properties": {
                "meta": {
                    "type": "object",
                    "properties": {
                        "styleName": { "type": "string" },
                        "aspectRatio": { "type": "string" },
                        "promptPrefix": { "type": "string" }
                    }
                },
                "camera": {
                    "type": "object",
                    "properties": {
                        "model": { "type": "string" },
                        "focal": { "type": "string" },
                        "angle": { "type": "string" },
                        "type": { "type": "string" }
                    }
                },
                "subject": {
                    "type": "object",
                    "properties": {
                        "main": { "type": "string" },
                        "emotion": { "type": "string" },
                        "pose": { "type": "string" },
                        "gaze": { "type": "string" }
                    }
                },
                "character": {
                    "type": "object",
                    "properties": {
                        "appearance": { "type": "string" },
                        "clothing": { "type": "string" },
                        "accessories": { "type": "string" }
                    }
                },
                "composition": {
                    "type": "object",
                    "properties": {
                        "theory": { "type": "string" },
                        "hierarchy": { "type": "string" }
                    }
                },
                "setting": {
                    "type": "object",
                    "properties": {
                        "environment": { "type": "string" },
                        "architecture": { "type": "string" },
                        "furniture": { "type": "string" }
                    }
                },
                "lighting": {
                    "type": "object",
                    "properties": {
                        "source": { "type": "string" },
                        "direction": { "type": "string" },
                        "quality": { "type": "string" }
                    }
                },
                "style": {
                    "type": "object",
                    "properties": {
                        "artistic": { "type": "string" },
                        "mood": { "type": "string" }
                    }
                },
                "rendering": {
                    "type": "object",
                    "properties": {
                        "engine": { "type": "string" },
                        "fidelity": { "type": "string" },
                        "postProcessing": { "type": "string" }
                    }
                },
                "colorPalette": {
                    "type": "object",
                    "properties": {
                        "primary": { "type": "string" },
                        "accent": { "type": "string" }
                    }
                }
            }
        };

        // 常數定義
        const CONSTANTS = {
            CSS_CLASSES: {
                STATUS_ERROR: 'status-error',
                STATUS_SUCCESS: 'status-success',
                STATUS_LOADING: 'status-loading',
                STATUS_INFO: 'status-info'
            },
            DOM_IDS: {
                API_KEY: 'apiKey',
                PROMPT: 'prompt',
                AUTO_TRANSLATE: 'autoTranslate',
                UI_LANGUAGE: 'uiLanguage',
                ASPECT_RATIO: 'aspectRatio',
                MODEL_SELECT: 'modelSelect',
                ENHANCE_PROMPT_BTN: 'enhancePromptBtn',
                GENERATE_BTN: 'generateBtn',
                DOWNLOAD_BTN: 'downloadBtn',
                CLEAR_BTN: 'clearBtn',
                HISTORY_BTN: 'historyBtn',
                LOAD_MORE_BTN: 'loadMoreBtn',
                STATUS: 'status',
                IMAGE_CONTAINER: 'imageContainer',
                RIGHT_PANEL: 'rightPanel',
                HISTORY_GRID: 'historyGrid'
            },
            EVENTS: {
                CLICK: 'click',
                BLUR: 'blur',
                CHANGE: 'change',
                KEYDOWN: 'keydown'
            },
            DOWNLOAD: {
                FILE_PREFIX: 'gemini-image',
                FILE_EXTENSION: '.jpg',
                MIME_TYPE: 'image/jpeg'
            }
        };

        /**
         * 工具類別 - 提供通用工具方法
         */
        class Utils {
            /**
             * 生成時間戳記
             * @returns {string} ISO 格式時間戳記，替換特殊字符
             */
            static generateTimestamp() {
                return new Date().toISOString().replace(/[:.]/g, '-');
            }

            /**
             * 處理檔案名稱
             * @param {string} prefix - 檔案前綴
             * @param {string} aspectRatio - 長寬比例
             * @param {string} extension - 檔案副檔名
             * @returns {string} 格式化的檔案名稱
             */
            static generateFilename(prefix, aspectRatio, extension) {
                const timestamp = this.generateTimestamp();
                const formattedRatio = aspectRatio.replace(':', 'x');
                return `${prefix}-${formattedRatio}-${timestamp}${extension}`;
            }

            /**
             * 驗證字串是否為空
             * @param {string} value - 要驗證的值
             * @returns {boolean} 是否為有效值
             */
            static isValidString(value) {
                return typeof value === 'string' && value.trim().length > 0;
            }

            /**
             * 安全的 JSON 解析
             * @param {string} jsonString - JSON 字串
             * @param {*} defaultValue - 預設值
             * @returns {*} 解析結果或預設值
             */
            static safeJsonParse(jsonString, defaultValue = null) {
                try {
                    return JSON.parse(jsonString);
                } catch (error) {
                    return defaultValue;
                }
            }

            /**
             * 檢查是否啟用除錯模式
             * @returns {boolean} 是否啟用除錯模式
             */
            static isDebugMode() {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get('debug') === 'true';
            }

            /**
             * 從 CSS 背景樣式中提取 Base64 圖片資料
             * @param {string} backgroundImageStyle - CSS background-image 樣式值
             * @returns {string|null} Base64 資料或 null
             */
            static extractBase64FromBackgroundImage(backgroundImageStyle) {
                if (!backgroundImageStyle || typeof backgroundImageStyle !== 'string') {
                    return null;
                }

                try {
                    // 匹配 url("data:image/...;base64,xxxxx") 格式
                    const match = backgroundImageStyle.match(/url\(["']?data:image\/[^;]+;base64,([^"')]+)["']?\)/);

                    if (match && match[1]) {
                        return match[1];
                    }

                    // 嘗試匹配簡單的 data:image/...;base64,xxxxx 格式
                    const simpleMatch = backgroundImageStyle.match(/data:image\/[^;]+;base64,([^"')]+)/);
                    if (simpleMatch && simpleMatch[1]) {
                        return simpleMatch[1];
                    }

                    return null;
                } catch (error) {
                    Logger.error('提取 Base64 資料時發生錯誤:', error);
                    return null;
                }
            }

            /**
             * 將 Base64 資料轉換為 Blob
             * @param {string} base64Data - Base64 編碼的圖片資料
             * @param {string} mimeType - MIME 類型，預設為 'image/jpeg'
             * @returns {Blob|null} Blob 物件或 null
             */
            static base64ToBlob(base64Data, mimeType = 'image/jpeg') {
                if (!base64Data || typeof base64Data !== 'string') {
                    return null;
                }

                try {
                    // 移除可能的空白字符
                    const cleanBase64 = base64Data.replace(/\s/g, '');

                    // 解碼 Base64
                    const byteCharacters = atob(cleanBase64);
                    const byteNumbers = new Array(byteCharacters.length);

                    for (let i = 0; i < byteCharacters.length; i++) {
                        byteNumbers[i] = byteCharacters.charCodeAt(i);
                    }

                    const byteArray = new Uint8Array(byteNumbers);
                    return new Blob([byteArray], { type: mimeType });
                } catch (error) {
                    Logger.error('Base64 轉 Blob 時發生錯誤:', error);
                    return null;
                }
            }

            /**
             * 在新分頁中開啟圖片
             * @param {string} base64Data - Base64 編碼的圖片資料
             * @param {string} mimeType - MIME 類型，預設為 'image/jpeg'
             * @returns {boolean} 是否成功開啟
             */
            static openImageInNewTab(base64Data, mimeType = 'image/jpeg') {
                if (!base64Data) {
                    Logger.error('無效的 Base64 資料');
                    return false;
                }

                try {
                    // 方法 1: 嘗試使用 Blob URL（推薦）
                    const blob = this.base64ToBlob(base64Data, mimeType);
                    if (blob) {
                        const blobUrl = URL.createObjectURL(blob);
                        const newWindow = window.open(blobUrl, '_blank');

                        if (newWindow) {
                            // 在新視窗載入後清理 Blob URL（可選）
                            newWindow.addEventListener('load', () => {
                                // 延遲清理，確保圖片已載入
                                setTimeout(() => {
                                    URL.revokeObjectURL(blobUrl);
                                }, 1000);
                            });

                            Logger.info('成功使用 Blob URL 在新分頁中開啟圖片');
                            return true;
                        }
                    }

                    // 方法 2: 回退到 Data URL
                    const dataUrl = `data:${mimeType};base64,${base64Data}`;
                    const fallbackWindow = window.open(dataUrl, '_blank');

                    if (fallbackWindow) {
                        Logger.info('使用 Data URL 在新分頁中開啟圖片');
                        return true;
                    }

                    Logger.error('無法開啟新分頁');
                    return false;
                } catch (error) {
                    Logger.error('開啟圖片時發生錯誤:', error);
                    return false;
                }
            }

            /**
             * 從 DOM 元素中提取並開啟圖片
             * @param {HTMLElement} element - 包含背景圖片的 DOM 元素
             * @returns {boolean} 是否成功開啟
             */
            static openImageFromElement(element) {
                if (!element) {
                    Logger.error('無效的 DOM 元素');
                    return false;
                }

                try {
                    const computedStyle = window.getComputedStyle(element);
                    const backgroundImage = computedStyle.backgroundImage;

                    if (!backgroundImage || backgroundImage === 'none') {
                        Logger.warn('元素沒有背景圖片');
                        return false;
                    }

                    const base64Data = this.extractBase64FromBackgroundImage(backgroundImage);
                    if (!base64Data) {
                        Logger.error('無法從背景樣式中提取 Base64 資料');
                        return false;
                    }

                    // 嘗試從背景樣式推斷 MIME 類型
                    let mimeType = 'image/jpeg'; // 預設值
                    if (backgroundImage.includes('data:image/png')) {
                        mimeType = 'image/png';
                    } else if (backgroundImage.includes('data:image/webp')) {
                        mimeType = 'image/webp';
                    }

                    return this.openImageInNewTab(base64Data, mimeType);
                } catch (error) {
                    Logger.error('從元素開啟圖片時發生錯誤:', error);
                    return false;
                }
            }
        }

        /**
         * 日誌管理類別 - 統一管理應用程式日誌輸出
         */
        class Logger {
            static isDevelopment = this.checkDebugMode(); // 根據URL參數決定是否啟用開發模式日誌

            /**
             * 檢查是否啟用debug模式
             * @returns {boolean} 是否啟用debug模式
             */
            static checkDebugMode() {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get('debug') === 'true';
            }

            /**
             * 資訊日誌
             * @param {string} message - 日誌訊息
             * @param {...any} args - 額外參數
             */
            static info(message, ...args) {
                if (this.isDevelopment) {
                    console.log(`[INFO] ${message}`, ...args);
                }
            }

            /**
             * 警告日誌
             * @param {string} message - 日誌訊息
             * @param {...any} args - 額外參數
             */
            static warn(message, ...args) {
                if (this.isDevelopment) {
                    console.warn(`[WARN] ${message}`, ...args);
                }
            }

            /**
             * 錯誤日誌
             * @param {string} message - 日誌訊息
             * @param {...any} args - 額外參數
             */
            static error(message, ...args) {
                if (this.isDevelopment) {
                    console.error(`[ERROR] ${message}`, ...args);
                }
            }
        }

        /**
         * 語言管理類別 - 處理介面語言和提示詞語言的管理
         */
        class LanguageManager {
            constructor() {
                this.currentLanguage = CONFIG.LANGUAGE.DEFAULT; // 提示詞語言
                this.currentUILanguage = CONFIG.UI_LANGUAGE.DEFAULT; // 介面語言
                this.init();
            }

            /**
             * 初始化語言管理器
             */
            init() {
                // 初始化介面語言（優先處理）
                const urlUILanguage = this.getUILanguageFromURL();
                const savedUILanguage = this.getUILanguageFromStorage();
                const browserLanguage = this.detectBrowserLanguage();
                let targetUILanguage = urlUILanguage || savedUILanguage || browserLanguage || CONFIG.UI_LANGUAGE.DEFAULT;

                if (!this.isUILanguageSupported(targetUILanguage)) {
                    Logger.warn(`不支援的介面語言: ${targetUILanguage}，使用預設語言: ${CONFIG.UI_LANGUAGE.DEFAULT}`);
                    targetUILanguage = CONFIG.UI_LANGUAGE.DEFAULT;
                }

                this.setUILanguage(targetUILanguage);

                // 提示詞語言自動跟隨介面語言
                this.currentLanguage = this.getCurrentPromptLanguage();

                Logger.info(`語言管理器初始化完成，介面語言: ${this.currentUILanguage}，提示詞語言: ${this.currentLanguage}`);
            }

            /**
             * 偵測瀏覽器語言
             * @returns {string|null} 支援的語言代碼或null
             */
            detectBrowserLanguage() {
                const browserLang = navigator.language || navigator.userLanguage;
                if (!browserLang) return null;

                // 語言代碼映射表
                const langMap = {
                    'zh': 'zh-tw',
                    'zh-tw': 'zh-tw',
                    'zh-hk': 'zh-tw',
                    'zh-cn': 'zh-cn',
                    'zh-hans': 'zh-cn',
                    'zh-hant': 'zh-tw',
                    'en': 'en',
                    'en-us': 'en',
                    'en-gb': 'en',
                    'ja': 'ja',
                    'ja-jp': 'ja'
                };

                const detectedLang = langMap[browserLang.toLowerCase()];
                if (detectedLang && this.isUILanguageSupported(detectedLang)) {
                    Logger.info(`偵測到瀏覽器語言: ${browserLang} -> ${detectedLang}`);
                    return detectedLang;
                }

                return null;
            }

            /**
             * 從URL參數獲取介面語言設定
             * @returns {string|null} 語言代碼或null
             */
            getUILanguageFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                const lang = urlParams.get(CONFIG.UI_LANGUAGE.URL_PARAM);
                return lang ? lang.toLowerCase() : null;
            }

            /**
             * 從localStorage獲取介面語言設定
             * @returns {string|null} 語言代碼或null
             */
            getUILanguageFromStorage() {
                return localStorage.getItem(CONFIG.STORAGE.UI_LANGUAGE);
            }

            /**
             * 檢查介面語言是否受支援
             * @param {string} language - 語言代碼
             * @returns {boolean} 是否受支援
             */
            isUILanguageSupported(language) {
                return CONFIG.UI_LANGUAGE.SUPPORTED.includes(language.toLowerCase());
            }

            /**
             * 設定介面語言
             * @param {string} language - 語言代碼
             * @returns {boolean} 是否成功設定
             */
            setUILanguage(language) {
                if (!this.isUILanguageSupported(language)) {
                    Logger.error(`嘗試設定不支援的介面語言: ${language}`);
                    return false;
                }

                this.currentUILanguage = language.toLowerCase();
                localStorage.setItem(CONFIG.STORAGE.UI_LANGUAGE, this.currentUILanguage);

                // 自動更新提示詞語言以跟隨介面語言
                this.currentLanguage = this.getCurrentPromptLanguage();

                this.updateHTMLLangAttribute();

                Logger.info(`介面語言已設定為: ${this.currentUILanguage}，提示詞語言自動設定為: ${this.currentLanguage}`);
                return true;
            }

            /**
             * 獲取當前介面語言
             * @returns {string} 當前介面語言代碼
             */
            getCurrentUILanguage() {
                return this.currentUILanguage;
            }

            /**
             * 根據當前介面語言獲取對應的提示詞語言
             * @returns {string} 提示詞語言代碼
             */
            getCurrentPromptLanguage() {
                const mapping = CONFIG.PROMPT_LANGUAGE.UI_TO_PROMPT_MAPPING;
                return mapping[this.currentUILanguage] || 'en';
            }

            /**
             * 獲取 UI 文字
             * @param {string} key - 文字鍵值
             * @param {string} category - 分類（如 'labels', 'buttons', 'messages'）
             * @param {string} language - 語言代碼（可選，預設使用當前介面語言）
             * @returns {string} 對應的文字內容
             */
            getUIText(key, category, language = null) {
                const targetLanguage = language || this.currentUILanguage;

                if (!UI_LANG_RESOURCES[targetLanguage]) {
                    Logger.warn(`找不到語言資源: ${targetLanguage}，使用預設語言`);
                    const defaultRes = UI_LANG_RESOURCES[CONFIG.UI_LANGUAGE.DEFAULT];
                    if (category === key) {
                        // 當 category 和 key 相同時，直接訪問屬性
                        return defaultRes?.[key] || key;
                    }
                    return defaultRes?.[category]?.[key] || key;
                }

                const resource = UI_LANG_RESOURCES[targetLanguage];
                if (category === key) {
                    // 當 category 和 key 相同時，直接訪問屬性
                    return resource?.[key] || key;
                }
                return resource?.[category]?.[key] || key;
            }

            /**
             * 更新介面語言
             * @param {string} language - 語言代碼
             * @returns {boolean} 是否成功更新
             */
            updateInterface(language) {
                if (!this.setUILanguage(language)) {
                    return false;
                }

                // 更新頁面標題和主標題
                document.title = this.getUIText('pageTitle', 'pageTitle');
                const h1Element = document.querySelector('h1');
                if (h1Element) {
                    h1Element.textContent = this.getUIText('title', 'title');
                }

                // 更新所有 DOM 元素的文字
                this.updateDOMElements();

                // 更新 URL 參數
                this.updateUILanguageURLParameter(language);

                return true;
            }

            /**
             * 更新所有 DOM 元素的文字內容
             */
            updateDOMElements() {
                // DOM 元素選擇器映射表
                const elementMap = {
                    // 標籤文字
                    'label[for="apiKey"]': { category: 'labels', key: 'apiKey' },
                    'label[for="aspectRatio"]': { category: 'labels', key: 'aspectRatio' },
                    'label[for="modelSelect"]': { category: 'labels', key: 'modelSelect' },
                    'label[for="prompt"]': { category: 'labels', key: 'prompt' },
                    'label[for="autoTranslate"]': { category: 'labels', key: 'autoTranslate' },
                    'label[for="uiLanguage"]': { category: 'labels', key: 'uiLanguage' },

                    // 按鈕文字
                    '#enhancePromptBtn': { category: 'buttons', key: 'enhancePrompt' },
                    '#generateBtn': { category: 'buttons', key: 'generateImage' },
                    '#downloadBtn': { category: 'buttons', key: 'downloadImage' },
                    '#clearBtn': { category: 'buttons', key: 'clearImage' },
                    '#historyBtn': { category: 'buttons', key: 'history' },
                    '#loadMoreBtn': { category: 'buttons', key: 'loadMore' },

                    // 提示文字
                    '#apiKey': { category: 'placeholders', key: 'apiKey', attribute: 'placeholder' },
                    '#prompt': { category: 'placeholders', key: 'prompt', attribute: 'placeholder' },

                    // 預設圖片文字
                    '#imageContainer p': { category: 'placeholders', key: 'defaultImageText' }
                };

                // 更新元素文字
                Object.entries(elementMap).forEach(([selector, config]) => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(element => {
                        const text = this.getUIText(config.key, config.category);
                        if (config.attribute) {
                            element.setAttribute(config.attribute, text);
                        } else {
                            element.textContent = text;
                        }
                    });
                });

                // 更新選項文字
                this.updateSelectOptions();
            }

            /**
             * 更新選項文字
             */
            updateSelectOptions() {
                // 更新是/否選項
                const yesText = this.getUIText('yes', 'options');
                const noText = this.getUIText('no', 'options');

                const autoTranslateSelect = document.getElementById('autoTranslate');
                if (autoTranslateSelect) {
                    const options = autoTranslateSelect.querySelectorAll('option');
                    options.forEach(option => {
                        if (option.value === 'yes') {
                            option.textContent = yesText;
                        } else if (option.value === 'no') {
                            option.textContent = noText;
                        }
                    });
                }

                // 更新介面語言選項
                const uiLanguageSelect = document.getElementById('uiLanguage');
                if (uiLanguageSelect) {
                    const options = uiLanguageSelect.querySelectorAll('option');
                    options.forEach(option => {
                        const langCode = option.value;
                        const langName = this.getUIText('uiLanguages', 'options')?.[langCode];
                        if (langName) {
                            option.textContent = langName;
                        }
                    });
                }
            }

            /**
             * 切換介面語言
             * @param {string} language - 語言代碼
             * @returns {boolean} 是否成功切換
             */
            switchUILanguage(language) {
                return this.updateInterface(language);
            }

            /**
             * 更新介面語言 URL 參數
             * @param {string} language - 語言代碼
             */
            updateUILanguageURLParameter(language) {
                const url = new URL(window.location);
                url.searchParams.set(CONFIG.UI_LANGUAGE.URL_PARAM, language);
                window.history.replaceState({}, '', url);
                Logger.info(`介面語言 URL 參數已更新: ${CONFIG.UI_LANGUAGE.URL_PARAM}=${language}`);
            }

            // === 以下保持原有的提示詞語言管理方法 ===

            /**
             * 從URL參數獲取語言設定
             * @returns {string|null} 語言代碼或null
             */
            getLanguageFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                const lang = urlParams.get(CONFIG.LANGUAGE.URL_PARAM);
                return lang || null; // 保持原始格式
            }

            /**
             * 從localStorage獲取語言設定
             * @returns {string|null} 語言代碼或null
             */
            getLanguageFromStorage() {
                return localStorage.getItem(CONFIG.STORAGE.LANGUAGE);
            }

            /**
             * 檢查語言是否受支援
             * @param {string} language - 語言代碼
             * @returns {boolean} 是否受支援
             */
            isLanguageSupported(language) {
                const supportedLanguages = Object.values(CONFIG.PROMPT_LANGUAGE.UI_TO_PROMPT_MAPPING);
                return supportedLanguages.includes(language);
            }

            /**
             * 設定當前語言
             * @param {string} language - 語言代碼
             */
            setLanguage(language) {
                if (!this.isLanguageSupported(language)) {
                    Logger.error(`嘗試設定不支援的語言: ${language}`);
                    return false;
                }

                this.currentLanguage = language; // 保持原始格式，不轉換大小寫

                // 保存到localStorage
                localStorage.setItem(CONFIG.STORAGE.LANGUAGE, this.currentLanguage);

                // 更新HTML lang屬性
                this.updateHTMLLangAttribute();

                Logger.info(`語言已設定為: ${this.currentLanguage}`);
                return true;
            }

            /**
             * 更新HTML的lang屬性（使用介面語言）
             */
            updateHTMLLangAttribute() {
                const htmlElement = document.documentElement;
                let langAttr = this.currentUILanguage;

                // 轉換語言代碼為正確的HTML lang屬性格式
                switch (this.currentUILanguage) {
                    case 'zh-tw':
                        langAttr = 'zh-TW';
                        break;
                    case 'zh-cn':
                        langAttr = 'zh-CN';
                        break;
                    case 'ja':
                        langAttr = 'ja';
                        break;
                    case 'en':
                    default:
                        langAttr = 'en';
                        break;
                }

                htmlElement.setAttribute('lang', langAttr);
                Logger.info(`HTML lang屬性已更新為: ${langAttr}`);
            }

            /**
             * 獲取當前語言
             * @returns {string} 當前語言代碼
             */
            getCurrentLanguage() {
                return this.currentLanguage;
            }

            /**
             * 獲取支援的語言列表
             * @returns {Array<string>} 支援的語言列表
             */
            getSupportedLanguages() {
                return Object.values(CONFIG.PROMPT_LANGUAGE.UI_TO_PROMPT_MAPPING);
            }

            /**
             * 更新URL參數（不重新載入頁面）
             * @param {string} language - 語言代碼
             */
            updateURLParameter(language) {
                const url = new URL(window.location);
                url.searchParams.set(CONFIG.LANGUAGE.URL_PARAM, language);
                window.history.replaceState({}, '', url);
                Logger.info(`URL參數已更新: ${CONFIG.LANGUAGE.URL_PARAM}=${language}`);
            }

            /**
             * 切換語言（會更新URL參數和localStorage）
             * @param {string} language - 語言代碼
             * @returns {boolean} 是否成功切換
             */
            switchLanguage(language) {
                if (this.setLanguage(language)) {
                    this.updateURLParameter(language);
                    return true;
                }
                return false;
            }

            /**
             * 從URL參數獲取提示詞語言設定
             * @returns {string|null} 語言代碼或null
             */
            static getPromptLanguageFromUrl() {
                const urlParams = new URLSearchParams(window.location.search);
                const lang = urlParams.get(CONFIG.LANGUAGE.URL_PARAM);
                if (!lang) return null;

                if (Utils.isDebugMode()) {
                    console.log('[LanguageManager] URL 提示詞語言參數:', lang);
                }

                return lang;
            }

            /**
             * 檢查提示詞語言是否受支援
             * @param {string} language - 語言代碼
             * @returns {boolean} 是否受支援
             */
            static isPromptLanguageSupported(language) {
                const supportedLanguages = Object.values(CONFIG.PROMPT_LANGUAGE.UI_TO_PROMPT_MAPPING);
                return supportedLanguages.includes(language);
            }
        }

        /**
         * IndexedDB 服務類別 - 管理圖片歷史記錄的資料庫操作
         */
        class IndexedDBService {
            constructor() {
                this.dbName = 'GeminiImageHistory';
                this.dbVersion = 1;
                this.storeName = 'images';
                this.db = null;
            }

            /**
             * 初始化資料庫
             * @returns {Promise<IDBDatabase>} 資料庫實例
             */
            async initDatabase() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);

                    request.onerror = () => {
                        Logger.error('IndexedDB 開啟失敗:', request.error);
                        reject(new Error('無法開啟 IndexedDB 資料庫'));
                    };

                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        Logger.info('IndexedDB 初始化成功');
                        resolve(this.db);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;

                        // 建立 Object Store
                        if (!db.objectStoreNames.contains(this.storeName)) {
                            const store = db.createObjectStore(this.storeName, {
                                keyPath: 'id',
                                autoIncrement: true
                            });

                            // 建立索引
                            store.createIndex('timestamp', 'timestamp', { unique: false });
                            store.createIndex('prompt', 'prompt', { unique: false });
                            store.createIndex('aspectRatio', 'aspectRatio', { unique: false });
                            store.createIndex('model', 'model', { unique: false });

                            Logger.info('IndexedDB Object Store 建立完成');
                        }
                    };
                });
            }

            /**
             * 儲存圖片記錄
             * @param {Object} record - 圖片記錄
             * @returns {Promise<number>} 記錄 ID
             */
            async saveImageRecord(record) {
                if (!this.db) {
                    await this.initDatabase();
                }

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);

                    const request = store.add({
                        ...record,
                        timestamp: new Date().toISOString()
                    });

                    request.onsuccess = () => {
                        Logger.info('圖片記錄儲存成功:', request.result);
                        resolve(request.result);
                    };

                    request.onerror = () => {
                        Logger.error('儲存圖片記錄失敗:', request.error);
                        reject(new Error('儲存圖片記錄失敗'));
                    };
                });
            }

            /**
             * 分頁載入歷史記錄
             * @param {number} offset - 偏移量
             * @param {number} limit - 限制數量
             * @returns {Promise<Array>} 記錄陣列
             */
            async loadImageHistory(offset = 0, limit = 20) {
                if (!this.db) {
                    await this.initDatabase();
                }

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    const index = store.index('timestamp');

                    const request = index.openCursor(null, 'prev'); // 按時間倒序
                    const results = [];
                    let count = 0;
                    let skipped = 0;

                    request.onsuccess = (event) => {
                        const cursor = event.target.result;

                        if (cursor && count < limit) {
                            if (skipped < offset) {
                                skipped++;
                                cursor.continue();
                                return;
                            }

                            results.push(cursor.value);
                            count++;
                            cursor.continue();
                        } else {
                            resolve(results);
                        }
                    };

                    request.onerror = () => {
                        Logger.error('載入歷史記錄失敗:', request.error);
                        reject(new Error('載入歷史記錄失敗'));
                    };
                });
            }

            /**
             * 刪除單筆記錄
             * @param {number} id - 記錄 ID
             * @returns {Promise<boolean>} 刪除是否成功
             */
            async deleteImageRecord(id) {
                if (!this.db) {
                    await this.initDatabase();
                }

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);

                    const request = store.delete(id);

                    request.onsuccess = () => {
                        Logger.info('圖片記錄刪除成功:', id);
                        resolve(true);
                    };

                    request.onerror = () => {
                        Logger.error('刪除圖片記錄失敗:', request.error);
                        reject(new Error('刪除圖片記錄失敗'));
                    };
                });
            }

            /**
             * 清空所有歷史記錄
             * @returns {Promise<boolean>} 清空是否成功
             */
            async clearAllHistory() {
                if (!this.db) {
                    await this.initDatabase();
                }

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);

                    const request = store.clear();

                    request.onsuccess = () => {
                        Logger.info('所有歷史記錄已清空');
                        resolve(true);
                    };

                    request.onerror = () => {
                        Logger.error('清空歷史記錄失敗:', request.error);
                        reject(new Error('清空歷史記錄失敗'));
                    };
                });
            }

            /**
             * 取得儲存空間使用情況
             * @returns {Promise<Object>} 使用情況統計
             */
            async getStorageUsage() {
                if (!this.db) {
                    await this.initDatabase();
                }

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);

                    const request = store.count();

                    request.onsuccess = () => {
                        // 估算儲存大小（這是簡化的計算）
                        const recordCount = request.result;
                        const estimatedSize = recordCount * 500 * 1024; // 假設每筆記錄約 500KB

                        resolve({
                            recordCount,
                            estimatedSize,
                            estimatedSizeMB: Math.round(estimatedSize / 1024 / 1024 * 100) / 100
                        });
                    };

                    request.onerror = () => {
                        Logger.error('取得儲存使用情況失敗:', request.error);
                        reject(new Error('取得儲存使用情況失敗'));
                    };
                });
            }

            /**
             * 自動清理舊記錄
             * @param {number} maxRecords - 最大記錄數
             * @returns {Promise<number>} 刪除的記錄數
             */
            async autoCleanup(maxRecords = 100) {
                const usage = await this.getStorageUsage();

                if (usage.recordCount <= maxRecords) {
                    return 0;
                }

                const deleteCount = Math.ceil(usage.recordCount * 0.1); // 刪除最舊的 10%
                const oldRecords = await this.loadImageHistory(usage.recordCount - deleteCount, deleteCount);

                let deletedCount = 0;
                for (const record of oldRecords) {
                    try {
                        await this.deleteImageRecord(record.id);
                        deletedCount++;
                    } catch (error) {
                        Logger.warn('清理記錄失敗:', record.id, error);
                    }
                }

                Logger.info(`自動清理完成，刪除了 ${deletedCount} 筆記錄`);
                return deletedCount;
            }
        }

        /**
         * 歷史網格渲染類別 - 處理歷史記錄的網格顯示
         */
        class HistoryGridRenderer {
            constructor(languageManager = null) {
                this.container = null;
                this.selectedThumbnailId = null;
                this.loadedThumbnails = new Set();
                this.languageManager = languageManager;
            }

            /**
             * 渲染網格容器
             * @param {HTMLElement} container - 容器元素（右側面板）
             */
            renderGrid(container) {
                this.container = container;

                // 建立網格元素
                if (!container.querySelector('#historyGrid')) {
                    const gridElement = document.createElement('div');
                    gridElement.id = 'historyGrid';
                    gridElement.className = 'history-grid';
                    container.appendChild(gridElement);
                }

                // 確保載入更多容器存在（添加到網格內部）
                const grid = container.querySelector('#historyGrid');
                if (grid) {
                    let loadMoreContainer = grid.querySelector('.load-more-container');
                    if (!loadMoreContainer) {
                        loadMoreContainer = document.createElement('div');
                        loadMoreContainer.className = 'load-more-container';

                        const loadMoreText = this.languageManager ?
                            this.languageManager.getUIText('loadMore', 'buttons') :
                            '載入更多';

                        loadMoreContainer.innerHTML = `
                            <button id="loadMoreBtn" type="button">${loadMoreText}</button>
                        `;
                        grid.appendChild(loadMoreContainer);
                        Logger.info('載入更多按鈕容器已創建');
                    }
                }

                Logger.info('歷史網格容器已渲染');
            }

            /**
             * 新增縮圖到網格
             * @param {Object} record - 圖片記錄
             * @param {boolean} isSelected - 是否為選中狀態
             */
            addThumbnailToGrid(record, isSelected = false) {
                const grid = this.container?.querySelector('#historyGrid');
                if (!grid) {
                    Logger.warn('網格容器不存在，無法新增縮圖');
                    return;
                }

                // 檢查是否已存在
                if (this.loadedThumbnails.has(record.id)) {
                    return;
                }

                // 建立縮圖元素
                const thumbnailItem = document.createElement('div');
                thumbnailItem.className = `thumbnail-item ${isSelected ? 'selected' : ''}`;
                thumbnailItem.dataset.recordId = record.id;

                // 檢查是否為手機版
                const isMobile = window.innerWidth <= 480;

                // 建立縮圖內容
                if (isMobile) {
                    // 手機版：直接使用原圖
                    thumbnailItem.innerHTML = `
                        <img class="thumbnail-image" 
                             src="data:image/jpeg;base64,${record.imageData}" 
                             alt="Generated image"
                             loading="lazy">
                        <div class="thumbnail-tooltip">${this.truncatePrompt(record.prompt)}</div>
                    `;
                } else {
                    // 桌機版：使用縮圖
                    if (record.thumbnailData) {
                        thumbnailItem.innerHTML = `
                            <img class="thumbnail-image" 
                                 src="data:image/jpeg;base64,${record.thumbnailData}" 
                                 alt="Generated image"
                                 loading="lazy">
                            <div class="thumbnail-tooltip">${this.truncatePrompt(record.prompt)}</div>
                        `;
                    } else {
                        thumbnailItem.innerHTML = `
                            <div class="thumbnail-placeholder">載入中...</div>
                            <div class="thumbnail-tooltip">${this.truncatePrompt(record.prompt)}</div>
                        `;

                        // 異步生成縮圖
                        this.generateThumbnailAsync(record, thumbnailItem);
                    }
                }

                // 添加點擊事件
                thumbnailItem.addEventListener('click', () => {
                    this.handleThumbnailClick(record.id);
                });

                // 新增到網格（在載入更多按鈕之前）
                const loadMoreContainer = grid.querySelector('.load-more-container');
                if (loadMoreContainer) {
                    grid.insertBefore(thumbnailItem, loadMoreContainer);
                } else {
                    grid.appendChild(thumbnailItem);
                }

                this.loadedThumbnails.add(record.id);

                Logger.info(`縮圖已新增到網格: ID ${record.id}`);
            }

            /**
             * 異步生成縮圖
             * @param {Object} record - 圖片記錄
             * @param {HTMLElement} thumbnailItem - 縮圖元素
             */
            async generateThumbnailAsync(record, thumbnailItem) {
                try {
                    // 檢查是否為手機版，如果是就直接使用原圖
                    const isMobile = window.innerWidth <= 480;

                    if (isMobile) {
                        // 手機版直接使用原圖
                        const placeholder = thumbnailItem.querySelector('.thumbnail-placeholder');
                        if (placeholder) {
                            placeholder.outerHTML = `
                                <img class="thumbnail-image" 
                                     src="data:image/jpeg;base64,${record.imageData}" 
                                     alt="Generated image">
                            `;
                        }
                        return;
                    }

                    // 桌機版才生成縮圖
                    const thumbnailData = await ThumbnailGenerator.generateThumbnail(record.imageData);

                    // 更新縮圖顯示
                    const placeholder = thumbnailItem.querySelector('.thumbnail-placeholder');
                    if (placeholder) {
                        placeholder.outerHTML = `
                            <img class="thumbnail-image" 
                                 src="data:image/jpeg;base64,${thumbnailData}" 
                                 alt="Generated image">
                        `;
                    }

                    // 可選：將縮圖資料儲存回資料庫
                    // 這裡可以考慮更新記錄以包含縮圖資料

                } catch (error) {
                    Logger.error('異步生成縮圖失敗:', error);

                    // 顯示錯誤佔位圖
                    const placeholder = thumbnailItem.querySelector('.thumbnail-placeholder');
                    if (placeholder) {
                        placeholder.textContent = this.languageManager ?
                            this.languageManager.getUIText('thumbnailLoadFailed', 'messages') :
                            '載入失敗';
                        placeholder.style.color = '#f44336';
                    }
                }
            }

            /**
             * 清空網格
             */
            clearGrid() {
                const grid = this.container?.querySelector('#historyGrid');
                if (grid) {
                    // 保存載入更多按鈕容器
                    const loadMoreContainer = grid.querySelector('.load-more-container');

                    // 清空網格內容
                    grid.innerHTML = '';

                    // 重新加入載入更多按鈕容器
                    if (loadMoreContainer) {
                        grid.appendChild(loadMoreContainer);
                    }

                    this.loadedThumbnails.clear();
                    Logger.info('歷史網格已清空（保留載入更多按鈕）');
                }
            }

            /**
             * 顯示網格
             */
            showGrid() {
                const grid = this.container?.querySelector('#historyGrid');
                if (grid) {
                    grid.classList.add('active');
                    // 為右側面板添加歷史模式樣式
                    this.container.classList.add('history-mode');
                    // 隱藏 imageContainer
                    const imageContainer = this.container.querySelector('#imageContainer');
                    if (imageContainer) {
                        imageContainer.classList.add('hidden');
                    }
                }
            }

            /**
             * 隱藏網格
             */
            hideGrid() {
                const grid = this.container?.querySelector('#historyGrid');
                if (grid) {
                    grid.classList.remove('active');
                    // 移除右側面板的歷史模式樣式
                    this.container.classList.remove('history-mode');
                    // 顯示 imageContainer
                    const imageContainer = this.container.querySelector('#imageContainer');
                    if (imageContainer) {
                        imageContainer.classList.remove('hidden');
                    }

                    // 初始化載入更多按鈕狀態
                    this.setLoadMoreButtonState(false);
                }
            }

            /**
             * 高亮選中的縮圖
             * @param {number} recordId - 記錄 ID
             */
            highlightSelectedThumbnail(recordId) {
                // 移除之前的選中狀態
                const prevSelected = this.container?.querySelector('.thumbnail-item.selected');
                if (prevSelected) {
                    prevSelected.classList.remove('selected');
                }

                // 添加新的選中狀態
                const newSelected = this.container?.querySelector(`[data-record-id="${recordId}"]`);
                if (newSelected) {
                    newSelected.classList.add('selected');
                    this.selectedThumbnailId = recordId;
                }
            }

            /**
             * 處理縮圖點擊事件
             * @param {number} recordId - 記錄 ID
             */
            handleThumbnailClick(recordId) {
                // 觸發自定義事件
                const event = new CustomEvent('thumbnailClick', {
                    detail: { recordId }
                });
                document.dispatchEvent(event);
            }

            /**
             * 截斷提示詞顯示
             * @param {string} prompt - 原始提示詞
             * @param {number} maxLength - 最大長度
             * @returns {string} 截斷後的提示詞
             */
            truncatePrompt(prompt, maxLength = 50) {
                if (!prompt || prompt.length <= maxLength) {
                    return prompt || '';
                }
                return prompt.substring(0, maxLength) + '...';
            }

            /**
             * 顯示載入更多按鈕
             */
            showLoadMoreButton() {
                const container = this.container?.querySelector('.load-more-container');
                if (container) {
                    container.classList.add('active');
                    Logger.info('載入更多按鈕已顯示');
                } else {
                    Logger.warn('找不到載入更多按鈕容器');
                }
            }

            /**
             * 隱藏載入更多按鈕
             */
            hideLoadMoreButton() {
                const container = this.container?.querySelector('.load-more-container');
                if (container) {
                    container.classList.remove('active');
                    Logger.info('載入更多按鈕已隱藏');
                } else {
                    Logger.warn('找不到載入更多按鈕容器');
                }
            }

            /**
             * 設定載入更多按鈕狀態
             * @param {boolean} loading - 是否載入中
             */
            setLoadMoreButtonState(loading) {
                const button = this.container?.querySelector('#loadMoreBtn');
                if (button) {
                    button.disabled = loading;

                    const loadingText = this.languageManager ?
                        this.languageManager.getUIText('loadMoreLoading', 'messages') :
                        '載入中...';
                    const loadMoreText = this.languageManager ?
                        this.languageManager.getUIText('loadMore', 'buttons') :
                        '載入更多';

                    button.textContent = loading ? loadingText : loadMoreText;
                }
            }

            /**
             * 取得已載入的縮圖數量
             * @returns {number} 縮圖數量
             */
            getThumbnailCount() {
                return this.loadedThumbnails.size;
            }

            /**
             * 滾動到頂部
             */
            scrollToTop() {
                const grid = this.container?.querySelector('#historyGrid');
                if (grid) {
                    grid.scrollTop = 0;
                }
            }
        }

        /**
         * 縮圖生成類別 - 處理圖片縮圖的生成和轉換
         */
        class ThumbnailGenerator {
            static DEFAULT_THUMBNAIL_SIZE = 150;

            /**
             * 生成縮圖
             * @param {string} base64Data - Base64 圖片資料
             * @param {number} size - 縮圖尺寸 (預設 150px)
             * @returns {Promise<string>} Base64 縮圖資料
             */
            static async generateThumbnail(base64Data, size = this.DEFAULT_THUMBNAIL_SIZE) {
                return new Promise((resolve, reject) => {
                    try {
                        // 建立 Image 物件
                        const img = new Image();

                        img.onload = () => {
                            try {
                                // 建立 Canvas
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');

                                // 計算縮圖尺寸 (保持正方形，中心裁切)
                                canvas.width = size;
                                canvas.height = size;

                                // 計算裁切參數
                                const sourceSize = Math.min(img.width, img.height);
                                const sourceX = (img.width - sourceSize) / 2;
                                const sourceY = (img.height - sourceSize) / 2;

                                // 繪製縮圖 (中心裁切)
                                ctx.drawImage(
                                    img,
                                    sourceX, sourceY, sourceSize, sourceSize, // 來源區域
                                    0, 0, size, size // 目標區域
                                );

                                // 轉換為 Base64
                                const thumbnailData = canvas.toDataURL('image/jpeg', 0.8);
                                const base64Only = thumbnailData.split(',')[1];

                                Logger.info(`縮圖生成成功，尺寸: ${size}x${size}`);
                                resolve(base64Only);

                            } catch (error) {
                                Logger.error('縮圖繪製失敗:', error);
                                reject(new Error('縮圖繪製失敗'));
                            }
                        };

                        img.onerror = () => {
                            Logger.error('圖片載入失敗');
                            reject(new Error('圖片載入失敗'));
                        };

                        // 載入圖片
                        img.src = `data:image/jpeg;base64,${base64Data}`;

                    } catch (error) {
                        Logger.error('生成縮圖時發生錯誤:', error);
                        reject(error);
                    }
                });
            }

            /**
             * Base64 轉 Blob
             * @param {string} base64Data - Base64 資料
             * @param {string} mimeType - MIME 類型
             * @returns {Blob} Blob 物件
             */
            static base64ToBlob(base64Data, mimeType = 'image/jpeg') {
                try {
                    const byteCharacters = atob(base64Data);
                    const byteNumbers = new Array(byteCharacters.length);

                    for (let i = 0; i < byteCharacters.length; i++) {
                        byteNumbers[i] = byteCharacters.charCodeAt(i);
                    }

                    const byteArray = new Uint8Array(byteNumbers);
                    return new Blob([byteArray], { type: mimeType });

                } catch (error) {
                    Logger.error('Base64 轉 Blob 失敗:', error);
                    throw new Error('Base64 轉換失敗');
                }
            }

            /**
             * Blob 轉 Data URL
             * @param {Blob} blob - Blob 物件
             * @returns {Promise<string>} Data URL
             */
            static blobToDataURL(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();

                    reader.onload = () => resolve(reader.result);
                    reader.onerror = () => reject(new Error('Blob 讀取失敗'));

                    reader.readAsDataURL(blob);
                });
            }

            /**
             * 計算最佳縮圖尺寸
             * @param {number} originalWidth - 原始寬度
             * @param {number} originalHeight - 原始高度
             * @param {number} maxSize - 最大尺寸
             * @returns {Object} {width, height}
             */
            static calculateOptimalSize(originalWidth, originalHeight, maxSize) {
                const aspectRatio = originalWidth / originalHeight;

                let width, height;

                if (aspectRatio > 1) {
                    // 寬度較大
                    width = Math.min(originalWidth, maxSize);
                    height = width / aspectRatio;
                } else {
                    // 高度較大或正方形
                    height = Math.min(originalHeight, maxSize);
                    width = height * aspectRatio;
                }

                return {
                    width: Math.round(width),
                    height: Math.round(height)
                };
            }

            /**
             * 批量生成縮圖
             * @param {Array} imageDataArray - Base64 圖片資料陣列
             * @param {number} size - 縮圖尺寸
             * @returns {Promise<Array>} 縮圖資料陣列
             */
            static async generateBatchThumbnails(imageDataArray, size = this.DEFAULT_THUMBNAIL_SIZE) {
                const promises = imageDataArray.map(data =>
                    this.generateThumbnail(data, size).catch(error => {
                        Logger.warn('批量縮圖生成失敗:', error);
                        return null; // 失敗時返回 null
                    })
                );

                const results = await Promise.all(promises);
                const successCount = results.filter(result => result !== null).length;

                Logger.info(`批量縮圖生成完成: ${successCount}/${imageDataArray.length}`);
                return results;
            }
        }

        /**
         * 本地儲存服務類別
         */
        class StorageService {
            /**
             * 儲存 API Key
             * @param {string} key - API Key
             * @returns {boolean} 儲存是否成功
             */
            static saveApiKey(key) {
                try {
                    if (!Utils.isValidString(key)) {
                        Logger.warn('嘗試儲存無效的 API Key');
                        return false;
                    }
                    localStorage.setItem(CONFIG.STORAGE.API_KEY, key.trim());
                    Logger.info('API Key 儲存成功');
                    return true;
                } catch (error) {
                    Logger.error('儲存 API Key 失敗:', error);
                    return false;
                }
            }

            /**
             * 載入 API Key
             * @returns {string|null} API Key 或 null
             */
            static loadApiKey() {
                try {
                    const key = localStorage.getItem(CONFIG.STORAGE.API_KEY);
                    if (Utils.isValidString(key)) {
                        Logger.info('API Key 載入成功');
                        return key.trim();
                    }
                    return null;
                } catch (error) {
                    Logger.error('載入 API Key 失敗:', error);
                    return null;
                }
            }

            /**
             * 儲存長寬比例
             * @param {string} ratio - 長寬比例
             * @returns {boolean} 儲存是否成功
             */
            static saveAspectRatio(ratio) {
                try {
                    if (!Utils.isValidString(ratio)) {
                        Logger.warn('嘗試儲存無效的長寬比例');
                        return false;
                    }
                    localStorage.setItem(CONFIG.STORAGE.ASPECT_RATIO, ratio);
                    Logger.info('長寬比例儲存成功:', ratio);
                    return true;
                } catch (error) {
                    Logger.error('儲存長寬比例失敗:', error);
                    return false;
                }
            }

            /**
             * 載入長寬比例
             * @returns {string} 長寬比例，失敗時返回預設值
             */
            static loadAspectRatio() {
                try {
                    const ratio = localStorage.getItem(CONFIG.STORAGE.ASPECT_RATIO);
                    if (Utils.isValidString(ratio)) {
                        Logger.info('長寬比例載入成功:', ratio);
                        return ratio;
                    }
                    Logger.info('使用預設長寬比例:', CONFIG.IMAGE.DEFAULT_ASPECT_RATIO);
                    return CONFIG.IMAGE.DEFAULT_ASPECT_RATIO;
                } catch (error) {
                    Logger.error('載入長寬比例失敗:', error);
                    return CONFIG.IMAGE.DEFAULT_ASPECT_RATIO;
                }
            }

            /**
             * 儲存模型選擇
             * @param {string} model - 模型名稱
             * @returns {boolean} 儲存是否成功
             */
            static saveModelSelection(model) {
                try {
                    if (!Utils.isValidString(model)) {
                        Logger.warn('嘗試儲存無效的模型選擇');
                        return false;
                    }
                    localStorage.setItem(CONFIG.STORAGE.MODEL_SELECTION, model);
                    Logger.info('模型選擇儲存成功:', model);
                    return true;
                } catch (error) {
                    Logger.error('儲存模型選擇失敗:', error);
                    return false;
                }
            }

            /**
             * 載入模型選擇
             * @returns {string} 模型名稱，失敗時返回預設值
             */
            static loadModelSelection() {
                try {
                    const model = localStorage.getItem(CONFIG.STORAGE.MODEL_SELECTION);
                    if (Utils.isValidString(model)) {
                        Logger.info('模型選擇載入成功:', model);
                        return model;
                    }
                    Logger.info('使用預設模型:', CONFIG.API.DEFAULT_MODEL);
                    return CONFIG.API.DEFAULT_MODEL;
                } catch (error) {
                    Logger.error('載入模型選擇失敗:', error);
                    return CONFIG.API.DEFAULT_MODEL;
                }
            }

            /**
             * 載入提示詞語言選擇（現已自動跟隨介面語言，此方法保留作為向後相容）
             * @returns {string} 語言代碼，失敗時返回預設值
             */
            static loadPromptLanguage() {
                // 提示詞語言現在自動跟隨介面語言，這個方法保留作為向後相容
                // 實際的提示詞語言會在LanguageManager中透過getCurrentPromptLanguage()取得
                return 'en'; // 返回預設值，實際不會被使用
            }

            /**
             * 儲存自動翻譯設定
             * @param {string} autoTranslate - 自動翻譯設定 ('yes' 或 'no')
             * @returns {boolean} 儲存是否成功
             */
            static saveAutoTranslate(autoTranslate) {
                try {
                    if (!Utils.isValidString(autoTranslate)) {
                        Logger.warn('嘗試儲存無效的自動翻譯設定');
                        return false;
                    }
                    localStorage.setItem(CONFIG.STORAGE.AUTO_TRANSLATE, autoTranslate);
                    if (Utils.isDebugMode()) {
                        console.log('[StorageService] 自動翻譯設定儲存成功:', autoTranslate);
                    }
                    Logger.info('自動翻譯設定儲存成功:', autoTranslate);
                    return true;
                } catch (error) {
                    Logger.error('儲存自動翻譯設定失敗:', error);
                    return false;
                }
            }

            /**
             * 載入自動翻譯設定
             * @returns {string} 自動翻譯設定，失敗時返回預設值 'no'
             */
            static loadAutoTranslate() {
                try {
                    const autoTranslate = localStorage.getItem(CONFIG.STORAGE.AUTO_TRANSLATE);
                    if (Utils.isValidString(autoTranslate) && (autoTranslate === 'yes' || autoTranslate === 'no')) {
                        if (Utils.isDebugMode()) {
                            console.log('[StorageService] 從 localStorage 載入自動翻譯設定:', autoTranslate);
                        }
                        Logger.info('自動翻譯設定載入成功:', autoTranslate);
                        return autoTranslate;
                    }

                    // 使用預設值
                    if (Utils.isDebugMode()) {
                        console.log('[StorageService] 使用預設自動翻譯設定: no');
                    }
                    Logger.info('使用預設自動翻譯設定: no');
                    return 'no';
                } catch (error) {
                    Logger.error('載入自動翻譯設定失敗:', error);
                    return 'no';
                }
            }

            /**
             * 儲存介面語言設定
             * @param {string} uiLanguage - 介面語言代碼
             * @returns {boolean} 儲存是否成功
             */
            static saveUILanguage(uiLanguage) {
                try {
                    if (!Utils.isValidString(uiLanguage)) {
                        Logger.warn('嘗試儲存無效的介面語言設定');
                        return false;
                    }
                    localStorage.setItem(CONFIG.STORAGE.UI_LANGUAGE, uiLanguage);
                    if (Utils.isDebugMode()) {
                        console.log('[StorageService] 介面語言設定儲存成功:', uiLanguage);
                    }
                    Logger.info('介面語言設定儲存成功:', uiLanguage);
                    return true;
                } catch (error) {
                    Logger.error('儲存介面語言設定失敗:', error);
                    return false;
                }
            }

            /**
             * 載入介面語言設定
             * @returns {string} 介面語言設定，失敗時返回預設值
             */
            static loadUILanguage() {
                try {
                    const uiLanguage = localStorage.getItem(CONFIG.STORAGE.UI_LANGUAGE);
                    if (Utils.isValidString(uiLanguage) && CONFIG.UI_LANGUAGE.SUPPORTED.includes(uiLanguage)) {
                        if (Utils.isDebugMode()) {
                            console.log('[StorageService] 從 localStorage 載入介面語言設定:', uiLanguage);
                        }
                        Logger.info('介面語言設定載入成功:', uiLanguage);
                        return uiLanguage;
                    }

                    // 使用預設值
                    if (Utils.isDebugMode()) {
                        console.log('[StorageService] 使用預設介面語言設定:', CONFIG.UI_LANGUAGE.DEFAULT);
                    }
                    Logger.info('使用預設介面語言設定:', CONFIG.UI_LANGUAGE.DEFAULT);
                    return CONFIG.UI_LANGUAGE.DEFAULT;
                } catch (error) {
                    Logger.error('載入介面語言設定失敗:', error);
                    return CONFIG.UI_LANGUAGE.DEFAULT;
                }
            }
        }

        /**
         * API 客戶端類別 - 處理與 Gemini API 的通訊
         */
        class ApiClient {
            /**
             * 建立請求資料
             * @param {string} prompt - 提示詞
             * @param {string} aspectRatio - 長寬比例
             * @returns {Object} 請求資料物件
             */
            static createRequestData(prompt, aspectRatio) {
                return {
                    instances: [
                        {
                            prompt: prompt
                        }
                    ],
                    parameters: {
                        outputMimeType: "image/jpeg",
                        sampleCount: 1,
                        personGeneration: "ALLOW_ADULT",
                        aspectRatio: aspectRatio
                    }
                };
            }

            /**
             * 建構 API URL
             * @param {string} apiKey - API Key
             * @param {string} model - 模型名稱
             * @returns {string} 完整的 API URL
             */
            static buildApiUrl(apiKey, model) {
                return `${CONFIG.API.BASE_URL}/${model}:predict?key=${apiKey}`;
            }

            /**
             * 分類 API 錯誤
             * @param {Response} response - HTTP 響應物件
             * @returns {string} 錯誤訊息
             */
            static categorizeError(response) {
                switch (response.status) {
                    case 401:
                        return CONFIG.ERROR_MESSAGES.INVALID_API_KEY;
                    case 429:
                        return CONFIG.ERROR_MESSAGES.RATE_LIMIT;
                    case 400:
                        return CONFIG.ERROR_MESSAGES.BAD_REQUEST;
                    default:
                        return `HTTP ${response.status}: ${response.statusText}`;
                }
            }

            /**
             * 處理 API 響應
             * @param {Response} response - HTTP 響應物件
             * @returns {Promise<string>} Base64 圖片資料
             */
            static async handleResponse(response) {
                if (!response.ok) {
                    const errorMessage = this.categorizeError(response);
                    Logger.error('API 請求失敗:', errorMessage);
                    throw new Error(errorMessage);
                }

                const data = await response.json();

                // 檢查響應資料格式
                if (!data.predictions || !data.predictions[0] || !data.predictions[0].bytesBase64Encoded) {
                    Logger.error('API 響應格式無效:', data);
                    throw new Error(CONFIG.ERROR_MESSAGES.INVALID_RESPONSE);
                }

                Logger.info('API 響應處理成功');
                return data.predictions[0].bytesBase64Encoded;
            }

            /**
             * 生成圖片
             * @param {string} apiKey - API Key
             * @param {string} prompt - 提示詞
             * @param {Object} options - 選項 {model, aspectRatio}
             * @returns {Promise<string>} Base64 圖片資料
             */
            static async generateImage(apiKey, prompt, options = {}) {
                const {
                    model = CONFIG.API.DEFAULT_MODEL,
                    aspectRatio = CONFIG.IMAGE.DEFAULT_ASPECT_RATIO
                } = options;

                try {
                    // 建立請求資料
                    const requestData = this.createRequestData(prompt, aspectRatio);

                    // 建構 API URL
                    const apiUrl = this.buildApiUrl(apiKey, model);

                    Logger.info('發送 API 請求:', { model, aspectRatio });

                    // 發送請求
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestData)
                    });

                    // 處理響應
                    return await this.handleResponse(response);

                } catch (error) {
                    Logger.error('生成圖片失敗:', error);
                    throw error;
                }
            }

            /**
             * 建立提示詞改善請求資料
             * @param {string} prompt - 原始提示詞
             * @returns {Object} 請求資料物件
             */
            static createEnhancePromptRequestData(prompt, language = 'en') {
                // 根據語言選擇添加指令前綴
                const languageInstruction = CONFIG.PROMPT_LANGUAGE.INSTRUCTIONS[language] || CONFIG.PROMPT_LANGUAGE.INSTRUCTIONS[CONFIG.PROMPT_LANGUAGE.DEFAULT];

                const systemPrompt = `${languageInstruction} Convert the attached user idea into a detailed JSON object for generating an image. The output should only be the raw JSON object, without any markdown formatting like \`\`\`json ... \`\`\`.

Idea: "${prompt}"

Schema:
{{
    "meta": {{
        "styleName": "...", // A unique, descriptive name for this specific image style or preset (e.g., "Ethereal Forest Magic", "Cyberpunk Noir Alley").
        "promptPrefix": "..." // Optional text to prepend to a generated prompt, like a file name, a version number, or a specific trigger word.
    }},
    "camera": {{
        "model": "...", // Describes the camera, lens, or artistic medium used (e.g., "DSLR", "iPhone 15 Pro", "8x10 view camera", "Watercolor on cold-press paper", "3D render in Blender").
        "focalLength": "...", // The lens's focal length, which affects the field of view and perspective distortion (e.g., "16mm wide-angle", "85mm portrait", "200mm telephoto", "Isometric perspective").
        "angle": "...", // The camera's angle relative to the main subject or scene (e.g., "eye-level", "high-angle", "dutch angle", "drone shot", "worm's-eye view").
        "type": "..." // The genre or type of photography or art style (e.g., "macro photography", "landscape", "fantasy illustration", "architectural rendering", "abstract art").
    }},
    "subject": {{
        "primary": "...", // The main focal point or subject of the image (e.g., "a majestic mountain range", "a lone wolf", "an ancient wizard", "a futuristic cityscape", "an abstract shape").
        "emotion": "...", // The dominant emotion or mood conveyed by the subject or the overall scene (e.g., "serene and peaceful", "joyful", "melancholy", "menacing", "awe-inspiring").
        "pose": "...", // The posture, action, or arrangement of the subject(s) (e.g., "running towards the camera", "sitting in quiet contemplation", "a winding river", "a chaotic explosion").
        "gaze": "..." // The direction of the subject's gaze or the directional focus of the composition (e.g., "looking off-camera", "breaking the fourth wall", "facing away from the viewer", "pointing towards the horizon").
    }},
    "character": {{
        "appearance": "...", // Detailed physical description of a character or key object (e.g., "weathered face with a long white beard", "sleek, chrome-plated robot", "moss-covered ancient tree").
        "wardrobe": "...", // Clothing, armor, or any form of covering on the subject (e.g., "ornate golden armor", "tattered rags", "a vibrant kimono", "a car's glossy paint job").
        "accessories": "..." // Additional items worn by or associated with the subject (e.g., "a magical amulet", "cybernetic implants", "a pair of glasses", "a sword and shield").
    }},
    "composition": {{
        "theory": "...", // The compositional rules or theories applied (e.g., "rule of thirds", "golden ratio", "leading lines", "symmetrical balance", "negative space").
        "visualHierarchy": "..." // Describes the order in which the viewer's eye is drawn to different elements in the scene, from most to least prominent.
    }},
    "setting": {{
        "environment": "...", // The general environment or location of the scene (e.g., "a mystical forest", "a bustling cyberpunk city", "a tranquil beach at sunset", "a minimalist white room", "the surface of Mars").
        "architecture": "...", // Describes any buildings, ruins, or significant natural structures (e.g., "gothic cathedrals", "brutalist architecture", "alien monoliths", "towering rock formations").
        "furniture": "..." // Key objects, props, or furniture within the setting that add context or detail (e.g., "a single throne", "scattered futuristic debris", "a rustic wooden fence").
    }},
    "lighting": {{
        "source": "...", // The primary source of light in the scene (e.g., "dramatic moonlight", "soft window light", "flickering candlelight", "neon signs", "magical glow").
        "direction": "...", // The direction from which the light originates (e.g., "backlighting", "rim lighting", "top-down light", "light from below").
        "quality": "..." // The quality and characteristics of the light and shadows (e.g., "soft and diffused", "hard and high-contrast", "dappled", "volumetric light rays", "caustic reflections").
    }},
    "style": {{
        "artDirection": "...", // The overarching artistic style, movement, or influence (e.g., "impressionism", "art deco", "cyberpunk", "vaporwave", "ghibli-inspired", "cinematic").
        "mood": "..." // The overall mood, feeling, or atmosphere of the image (e.g., "ethereal and dreamy", "dystopian and gritty", "whimsical and cheerful", "epic and dramatic").
    }},
    "rendering": {{
        "engine": "...", // The rendering engine, technique, or medium used to create the final image (e.g., "Octane Render", "oil painting", "cross-hatching", "pixel art", "Unreal Engine 5").
        "fidelitySpec": "...", // Specific details about the image's texture and fidelity (e.g., "heavy film grain", "sharp digital focus", "visible brushstrokes", "chromatic aberration", "lens flare").
        "postProcessing": "..." // Any post-processing or finishing effects applied (e.g., "color grading with a teal and orange look", "vignette", "bloom and glare", "a vintage photo filter").
    }},
    "colorPalette": {{
        "primaryColors": [ // The most dominant colors that define the overall color scheme of the image.
            {{ "name": "...", "hex": "...", "percentage": "..." }},
            {{ "name": "...", "hex": "...", "percentage": "..." }}
        ],
        "accentColors": [ // Complementary or contrasting colors used for emphasis, detail, or highlights.
            {{ "name": "...", "hex": "...", "percentage": "..." }},
            {{ "name": "...", "hex": "...", "percentage": "..." }}
        ]
    }}
}}
`;

                return {
                    contents: [
                        {
                            parts: [
                                {
                                    text: systemPrompt
                                }
                            ]
                        }
                    ],
                    generationConfig: {
                        thinkingConfig: {
                            thinkingBudget: -1,
                        },
                        responseMimeType: 'application/json',
                        responseSchema: {
                            type: 'object',
                            required: ["meta", "camera", "subject", "character", "composition", "setting", "lighting", "style", "rendering", "colorPalette"],
                            properties: {
                                meta: {
                                    type: 'object',
                                    required: ["styleName", "promptPrefix"],
                                    properties: {
                                        styleName: {
                                            type: 'string',
                                        },
                                        promptPrefix: {
                                            type: 'string',
                                        },
                                    },
                                },
                                camera: {
                                    type: 'object',
                                    required: ["model", "focalLength", "angle", "type"],
                                    properties: {
                                        model: {
                                            type: 'string',
                                        },
                                        focalLength: {
                                            type: 'string',
                                        },
                                        angle: {
                                            type: 'string',
                                        },
                                        type: {
                                            type: 'string',
                                        },
                                    },
                                },
                                subject: {
                                    type: 'object',
                                    required: ["primary", "emotion", "pose", "gaze"],
                                    properties: {
                                        primary: {
                                            type: 'string',
                                        },
                                        emotion: {
                                            type: 'string',
                                        },
                                        pose: {
                                            type: 'string',
                                        },
                                        gaze: {
                                            type: 'string',
                                        },
                                    },
                                },
                                character: {
                                    type: 'object',
                                    required: ["appearance", "wardrobe", "accessories"],
                                    properties: {
                                        appearance: {
                                            type: 'string',
                                        },
                                        wardrobe: {
                                            type: 'string',
                                        },
                                        accessories: {
                                            type: 'string',
                                        },
                                    },
                                },
                                composition: {
                                    type: 'object',
                                    required: ["theory", "visualHierarchy"],
                                    properties: {
                                        theory: {
                                            type: 'string',
                                        },
                                        visualHierarchy: {
                                            type: 'string',
                                        },
                                    },
                                },
                                setting: {
                                    type: 'object',
                                    required: ["environment", "architecture", "furniture"],
                                    properties: {
                                        environment: {
                                            type: 'string',
                                        },
                                        architecture: {
                                            type: 'string',
                                        },
                                        furniture: {
                                            type: 'string',
                                        },
                                    },
                                },
                                lighting: {
                                    type: 'object',
                                    required: ["source", "direction", "quality"],
                                    properties: {
                                        source: {
                                            type: 'string',
                                        },
                                        direction: {
                                            type: 'string',
                                        },
                                        quality: {
                                            type: 'string',
                                        },
                                    },
                                },
                                style: {
                                    type: 'object',
                                    required: ["artDirection", "mood"],
                                    properties: {
                                        artDirection: {
                                            type: 'string',
                                        },
                                        mood: {
                                            type: 'string',
                                        },
                                    },
                                },
                                rendering: {
                                    type: 'object',
                                    required: ["engine", "fidelitySpec", "postProcessing"],
                                    properties: {
                                        engine: {
                                            type: 'string',
                                        },
                                        fidelitySpec: {
                                            type: 'string',
                                        },
                                        postProcessing: {
                                            type: 'string',
                                        },
                                    },
                                },
                                colorPalette: {
                                    type: 'object',
                                    required: ["primaryColors", "accentColors"],
                                    properties: {
                                        primaryColors: {
                                            type: 'string',
                                        },
                                        accentColors: {
                                            type: 'string',
                                        },
                                    },
                                },
                            },
                        },
                    }
                };
            }

            /**
             * 建構提示詞改善 API URL
             * @param {string} apiKey - API Key
             * @returns {string} 完整的 API URL
             */
            static buildEnhancePromptApiUrl(apiKey) {
                return `${CONFIG.API.BASE_URL}/models/${CONFIG.API.MODELS.GEMINI_2_5_PRO}:generateContent?key=${apiKey}`;
            }

            /**
             * 處理提示詞改善 API 響應
             * @param {Response} response - HTTP 響應物件
             * @returns {Promise<Object>} 解析後的 JSON 物件
             */
            static async handleEnhancePromptResponse(response) {
                if (!response.ok) {
                    const errorMessage = this.categorizeError(response);
                    Logger.error('提示詞改善 API 請求失敗:', errorMessage);
                    throw new Error(errorMessage);
                }

                const data = await response.json();

                // 檢查響應資料格式
                if (!data.candidates || !data.candidates[0] || !data.candidates[0].content || !data.candidates[0].content.parts || !data.candidates[0].content.parts[0]) {
                    Logger.error('提示詞改善 API 響應格式無效:', data);
                    throw new Error(CONFIG.ERROR_MESSAGES.PROMPT_ENHANCE_INVALID_RESPONSE);
                }

                const jsonText = data.candidates[0].content.parts[0].text;

                try {
                    const parsedJson = JSON.parse(jsonText);
                    Logger.info('提示詞改善響應處理成功');
                    return parsedJson;
                } catch (parseError) {
                    Logger.error('JSON 解析失敗:', parseError);
                    throw new Error(CONFIG.ERROR_MESSAGES.PROMPT_ENHANCE_INVALID_RESPONSE);
                }
            }

            /**
             * 改善提示詞
             * @param {string} apiKey - API Key
             * @param {string} prompt - 原始提示詞
             * @param {string} language - 提示詞語言
             * @returns {Promise<Object>} 結構化的提示詞物件
             */
            static async enhancePrompt(apiKey, prompt, language = 'en') {
                try {
                    if (Utils.isDebugMode()) {
                        console.log('[ApiClient] 改善提示詞請求:', { prompt, language });
                    }

                    // 建立請求資料
                    const requestData = this.createEnhancePromptRequestData(prompt, language);

                    // 建構 API URL
                    const apiUrl = this.buildEnhancePromptApiUrl(apiKey);

                    Logger.info('發送提示詞改善 API 請求');

                    // 創建 AbortController 用於超時控制
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30秒超時

                    try {
                        // 發送請求
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(requestData),
                            signal: controller.signal
                        });

                        clearTimeout(timeoutId);

                        // 處理響應
                        return await this.handleEnhancePromptResponse(response);

                    } catch (fetchError) {
                        clearTimeout(timeoutId);

                        if (fetchError.name === 'AbortError') {
                            throw new Error(CONFIG.ERROR_MESSAGES.TIMEOUT_ERROR);
                        }

                        if (fetchError instanceof TypeError) {
                            throw new Error(CONFIG.ERROR_MESSAGES.NETWORK_ERROR);
                        }

                        throw fetchError;
                    }

                } catch (error) {
                    Logger.error('改善提示詞失敗:', error);
                    throw error;
                }
            }

            /**
             * 驗證 API 回應的語言是否符合要求
             * @param {Object} jsonData - API 回應的 JSON 資料
             * @param {string} expectedLanguage - 期望的語言
             * @returns {boolean} 是否符合語言要求
             */
            static validateResponseLanguage(jsonData, expectedLanguage) {
                try {
                    if (!jsonData || typeof jsonData !== 'object') {
                        return false;
                    }

                    // 取得所有字串值進行檢查
                    const textValues = this.extractTextValues(jsonData);

                    // 簡單的語言檢測邏輯
                    let languageMatches = 0;
                    const totalTexts = textValues.length;

                    if (totalTexts === 0) return false;

                    textValues.forEach(text => {
                        if (this.detectTextLanguage(text, expectedLanguage)) {
                            languageMatches++;
                        }
                    });

                    // 如果超過 70% 的文字符合期望語言，則認為通過
                    const matchRatio = languageMatches / totalTexts;
                    const isValid = matchRatio >= 0.7;

                    if (Utils.isDebugMode()) {
                        console.log('[ApiClient] 語言驗證結果:', {
                            expectedLanguage,
                            matchRatio: matchRatio.toFixed(2),
                            isValid,
                            totalTexts,
                            languageMatches
                        });
                    }

                    return isValid;
                } catch (error) {
                    Logger.error('語言驗證失敗:', error);
                    return false;
                }
            }

            /**
             * 從 JSON 物件中提取所有文字值
             * @param {Object} obj - JSON 物件
             * @returns {Array<string>} 文字值陣列
             */
            static extractTextValues(obj) {
                const textValues = [];

                const extract = (value) => {
                    if (typeof value === 'string' && value.trim().length > 0) {
                        textValues.push(value.trim());
                    } else if (typeof value === 'object' && value !== null) {
                        Object.values(value).forEach(extract);
                    }
                };

                extract(obj);
                return textValues;
            }

            /**
             * 簡單的文字語言檢測
             * @param {string} text - 要檢測的文字
             * @param {string} expectedLanguage - 期望的語言
             * @returns {boolean} 是否符合期望語言
             */
            static detectTextLanguage(text, expectedLanguage) {
                if (!text || typeof text !== 'string') return false;

                switch (expectedLanguage) {
                    case 'zh-TW':
                        // 檢測中文字符
                        return /[\u4e00-\u9fff]/.test(text);
                    case 'jp':
                        // 檢測日文字符（平假名、片假名、漢字）
                        return /[\u3040-\u309f\u30a0-\u30ff\u4e00-\u9fff]/.test(text);
                    case 'en':
                    default:
                        // 檢測英文字符（主要是拉丁字母，排除中日文）
                        return /[a-zA-Z]/.test(text) && !/[\u3040-\u309f\u30a0-\u30ff\u4e00-\u9fff]/.test(text);
                }
            }

            /**
             * 處理語言不符的情況
             * @param {string} expectedLanguage - 期望的語言
             * @param {LanguageManager} languageManager - 語言管理器
             * @returns {Promise<boolean>} 用戶是否選擇重試
             */
            static async handleLanguageMismatch(expectedLanguage, languageManager) {
                const languageNames = {
                    'en': languageManager.getUIText('languageNameEn', 'labels') || '英文',
                    'zh-TW': languageManager.getUIText('languageNameZhTw', 'labels') || '繁體中文',
                    'zh-CN': languageManager.getUIText('languageNameZhCn', 'labels') || '簡體中文',
                    'jp': languageManager.getUIText('languageNameJp', 'labels') || '日文'
                };

                const languageName = languageNames[expectedLanguage] || expectedLanguage;
                const message = languageManager.getUIText('confirmLanguageMismatch', 'messages').replace('{languageName}', languageName);

                return window.confirm(message);
            }

            /**
             * 翻譯提示詞
             * @param {string} apiKey - API Key
             * @param {string} content - 要翻譯的內容
             * @param {string} format - 內容格式
             * @returns {Promise<string>} 翻譯後的內容
             */
            static async translatePrompt(apiKey, content, format = 'text') {
                try {
                    if (Utils.isDebugMode()) {
                        console.log('[ApiClient] 翻譯提示詞請求:', { content, format });
                    }

                    // 建立請求資料
                    const requestData = this.createTranslationRequestData(content, format);

                    // 建構 API URL (使用與 enhancePrompt 相同的 API)
                    const apiUrl = this.buildEnhancePromptApiUrl(apiKey);

                    Logger.info('發送提示詞翻譯 API 請求');

                    // 創建 AbortController 用於超時控制
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), CONFIG.TRANSLATION.TIMEOUT);

                    try {
                        // 發送請求
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(requestData),
                            signal: controller.signal
                        });

                        clearTimeout(timeoutId);

                        // 處理響應
                        return await this.handleTranslationResponse(response);

                    } catch (fetchError) {
                        clearTimeout(timeoutId);

                        if (fetchError.name === 'AbortError') {
                            throw new Error('翻譯請求超時，請稍後再試');
                        }

                        if (fetchError instanceof TypeError) {
                            throw new Error('網路連接失敗，請檢查網路連接');
                        }

                        throw fetchError;
                    }

                } catch (error) {
                    Logger.error('翻譯提示詞失敗:', error);
                    throw error;
                }
            }

            /**
             * 建構翻譯請求資料
             * @param {string} content - 要翻譯的內容
             * @param {string} format - 內容格式
             * @returns {Object} 請求資料物件
             */
            static createTranslationRequestData(content, format) {
                let instruction = CONFIG.TRANSLATION.INSTRUCTION;

                // 根據內容格式調整翻譯指令
                if (format === 'json') {
                    instruction = 'Translate all JSON values to English while keeping the JSON structure intact.';
                } else if (format === 'text') {
                    instruction = 'Translate the following text to English.';
                } else {
                    instruction = 'Translate all text content to English while preserving any JSON structures and formatting.';
                }

                return {
                    contents: [
                        {
                            parts: [
                                {
                                    text: `${instruction}\n\nContent to translate:\n${content}`
                                }
                            ]
                        }
                    ],
                    generationConfig: {
                        thinkingConfig: {
                            thinkingBudget: -1,
                        },
                        responseMimeType: 'application/json',
                        responseSchema: {
                            type: 'object',
                            required: ["meta", "camera", "subject", "character", "composition", "setting", "lighting", "style", "rendering", "colorPalette"],
                            properties: {
                                meta: {
                                    type: 'object',
                                    required: ["styleName", "promptPrefix"],
                                    properties: {
                                        styleName: {
                                            type: 'string',
                                        },
                                        promptPrefix: {
                                            type: 'string',
                                        },
                                    },
                                },
                                camera: {
                                    type: 'object',
                                    required: ["model", "focalLength", "angle", "type"],
                                    properties: {
                                        model: {
                                            type: 'string',
                                        },
                                        focalLength: {
                                            type: 'string',
                                        },
                                        angle: {
                                            type: 'string',
                                        },
                                        type: {
                                            type: 'string',
                                        },
                                    },
                                },
                                subject: {
                                    type: 'object',
                                    required: ["primary", "emotion", "pose", "gaze"],
                                    properties: {
                                        primary: {
                                            type: 'string',
                                        },
                                        emotion: {
                                            type: 'string',
                                        },
                                        pose: {
                                            type: 'string',
                                        },
                                        gaze: {
                                            type: 'string',
                                        },
                                    },
                                },
                                character: {
                                    type: 'object',
                                    required: ["appearance", "wardrobe", "accessories"],
                                    properties: {
                                        appearance: {
                                            type: 'string',
                                        },
                                        wardrobe: {
                                            type: 'string',
                                        },
                                        accessories: {
                                            type: 'string',
                                        },
                                    },
                                },
                                composition: {
                                    type: 'object',
                                    required: ["theory", "visualHierarchy"],
                                    properties: {
                                        theory: {
                                            type: 'string',
                                        },
                                        visualHierarchy: {
                                            type: 'string',
                                        },
                                    },
                                },
                                setting: {
                                    type: 'object',
                                    required: ["environment", "architecture", "furniture"],
                                    properties: {
                                        environment: {
                                            type: 'string',
                                        },
                                        architecture: {
                                            type: 'string',
                                        },
                                        furniture: {
                                            type: 'string',
                                        },
                                    },
                                },
                                lighting: {
                                    type: 'object',
                                    required: ["source", "direction", "quality"],
                                    properties: {
                                        source: {
                                            type: 'string',
                                        },
                                        direction: {
                                            type: 'string',
                                        },
                                        quality: {
                                            type: 'string',
                                        },
                                    },
                                },
                                style: {
                                    type: 'object',
                                    required: ["artDirection", "mood"],
                                    properties: {
                                        artDirection: {
                                            type: 'string',
                                        },
                                        mood: {
                                            type: 'string',
                                        },
                                    },
                                },
                                rendering: {
                                    type: 'object',
                                    required: ["engine", "fidelitySpec", "postProcessing"],
                                    properties: {
                                        engine: {
                                            type: 'string',
                                        },
                                        fidelitySpec: {
                                            type: 'string',
                                        },
                                        postProcessing: {
                                            type: 'string',
                                        },
                                    },
                                },
                                colorPalette: {
                                    type: 'object',
                                    required: ["primaryColors", "accentColors"],
                                    properties: {
                                        primaryColors: {
                                            type: 'string',
                                        },
                                        accentColors: {
                                            type: 'string',
                                        },
                                    },
                                },
                            },
                        },
                    }
                };
            }

            /**
             * 處理翻譯 API 響應
             * @param {Response} response - HTTP 響應物件
             * @returns {Promise<string>} 翻譯後的內容
             */
            static async handleTranslationResponse(response) {
                if (!response.ok) {
                    const errorMessage = this.categorizeError(response);
                    Logger.error('翻譯 API 請求失敗:', errorMessage);
                    throw new Error(errorMessage);
                }

                const data = await response.json();

                // 檢查響應資料格式
                if (!data.candidates || !data.candidates[0] || !data.candidates[0].content ||
                    !data.candidates[0].content.parts || !data.candidates[0].content.parts[0]) {
                    throw new Error(CONFIG.ERROR_MESSAGES.TRANSLATION_INVALID_RESPONSE);
                }

                const responseText = data.candidates[0].content.parts[0].text;

                if (!responseText || typeof responseText !== 'string') {
                    throw new Error(CONFIG.ERROR_MESSAGES.TRANSLATION_INVALID_RESPONSE);
                }

                // 由於使用了 JSON schema，API 會返回 JSON 格式的翻譯結果
                // 需要將 JSON 物件轉換回原始格式的字串
                try {
                    const jsonData = JSON.parse(responseText);
                    // 將 JSON 物件轉換為格式化的字串
                    return JSON.stringify(jsonData, null, 2);
                } catch (parseError) {
                    // 如果解析失敗，返回原始文字
                    Logger.warn('翻譯響應 JSON 解析失敗，返回原始文字:', parseError.message);
                    return responseText.trim();
                }
            }
        }

        /**
         * 提示詞處理服務類別
         */
        class PromptEnhancer {
            /**
             * 將 JSON 物件轉換為換行文字格式
             * @param {Object} jsonData - 結構化的提示詞物件
             * @returns {string} 換行格式的文字
             */
            static jsonToReadablePrompt(jsonData) {
                return JSON.stringify(jsonData, null, 2);
            }

            /**
             * 驗證 JSON 物件是否有效
             * @param {Object} jsonData - 要驗證的 JSON 物件
             * @returns {boolean} 是否有效
             */
            static validateJsonStructure(jsonData) {
                if (!jsonData || typeof jsonData !== 'object') {
                    return false;
                }

                // 檢查是否至少有一個主要區塊有內容
                const requiredSections = ['subject', 'character', 'setting', 'style'];
                return requiredSections.some(section =>
                    jsonData[section] &&
                    typeof jsonData[section] === 'object' &&
                    Object.values(jsonData[section]).some(value => value && value.trim())
                );
            }
        }

        /**
         * 提示詞翻譯服務類別
         */
        class PromptTranslator {
            /**
             * 翻譯內容
             * @param {string} apiKey - API Key
             * @param {string} content - 要翻譯的內容
             * @returns {Promise<string>} 翻譯後的內容
             */
            static async translateContent(apiKey, content, languageManager = null) {
                try {
                    // 驗證翻譯輸入
                    const inputValidation = ValidationService.validateTranslationInput(content);
                    if (!inputValidation.isValid) {
                        throw new Error(inputValidation.message);
                    }

                    const contentFormat = inputValidation.format;

                    if (Utils.isDebugMode()) {
                        console.log('[PromptTranslator] 開始翻譯內容:', {
                            format: contentFormat,
                            contentLength: content.length
                        });
                    }

                    // 預處理內容
                    const processedContent = this.preprocessContent(content, contentFormat);

                    let translatedContent;
                    let retryCount = 0;

                    // 無限次重試機制
                    while (true) {
                        try {
                            // 調用翻譯 API
                            translatedContent = await ApiClient.translatePrompt(
                                apiKey,
                                processedContent,
                                contentFormat
                            );

                            // 驗證翻譯輸出
                            const outputValidation = ValidationService.validateTranslationOutput(
                                translatedContent,
                                contentFormat
                            );

                            if (!outputValidation.isValid) {
                                throw new Error(outputValidation.message);
                            }

                            // 翻譯成功，跳出重試循環
                            break;

                        } catch (error) {
                            retryCount++;

                            if (Utils.isDebugMode()) {
                                console.log(`[PromptTranslator] 翻譯失敗，重試次數: ${retryCount}`, error.message);
                            }

                            // 詢問用戶是否重試
                            let confirmMessage;
                            if (languageManager) {
                                confirmMessage = languageManager.getUIText('confirmRetryTranslation', 'messages').replace('{0}', error.message);
                            } else {
                                confirmMessage = `翻譯失敗：${error.message}\n\n是否要重試翻譯？`;
                            }
                            const shouldRetry = window.confirm(confirmMessage);

                            if (!shouldRetry) {
                                const cancelMessage = languageManager ?
                                    languageManager.getUIText('userCancelledTranslation', 'messages') :
                                    '用戶取消翻譯重試';
                                throw new Error(cancelMessage);
                            }
                        }
                    }

                    // 後處理內容
                    const finalContent = this.postprocessContent(translatedContent, contentFormat);

                    if (Utils.isDebugMode()) {
                        console.log('[PromptTranslator] 翻譯完成:', {
                            originalLength: content.length,
                            translatedLength: finalContent.length,
                            retryCount: retryCount
                        });
                        console.log('[PromptTranslator] 翻譯結果:', finalContent);
                    }

                    return finalContent;

                } catch (error) {
                    Logger.error('翻譯內容失敗:', error);
                    throw error;
                }
            }

            /**
             * 預處理內容
             * @param {string} content - 原始內容
             * @param {string} format - 內容格式
             * @returns {string} 預處理後的內容
             */
            static preprocessContent(content, format) {
                let processed = content.trim();

                // JSON 格式特殊處理
                if (format === 'json') {
                    try {
                        // 驗證並格式化 JSON
                        const jsonObj = JSON.parse(processed);
                        processed = JSON.stringify(jsonObj, null, 2);
                    } catch (error) {
                        Logger.warn('JSON 格式化失敗，使用原始內容:', error.message);
                    }
                }

                return processed;
            }

            /**
             * 後處理內容
             * @param {string} content - 翻譯後的內容
             * @param {string} format - 內容格式
             * @returns {string} 後處理後的內容
             */
            static postprocessContent(content, format) {
                let processed = content.trim();

                // JSON 格式特殊處理
                if (format === 'json') {
                    try {
                        // 嘗試解析並重新格式化
                        const jsonObj = JSON.parse(processed);
                        processed = JSON.stringify(jsonObj, null, 2);
                    } catch (error) {
                        Logger.warn('翻譯後 JSON 格式化失敗:', error.message);

                        // 嘗試修復常見的 JSON 格式問題
                        processed = this.repairJsonFormat(processed);
                    }
                }

                return processed;
            }

            /**
             * 修復 JSON 格式問題
             * @param {string} jsonString - 有問題的 JSON 字串
             * @returns {string} 修復後的 JSON 字串
             */
            static repairJsonFormat(jsonString) {
                try {
                    // 移除可能的前後綴文字
                    let cleaned = jsonString;

                    // 尋找第一個 { 和最後一個 }
                    const firstBrace = cleaned.indexOf('{');
                    const lastBrace = cleaned.lastIndexOf('}');

                    if (firstBrace !== -1 && lastBrace !== -1 && firstBrace < lastBrace) {
                        cleaned = cleaned.substring(firstBrace, lastBrace + 1);
                    }

                    // 嘗試解析修復後的 JSON
                    const jsonObj = JSON.parse(cleaned);
                    return JSON.stringify(jsonObj, null, 2);

                } catch (error) {
                    Logger.warn('JSON 修復失敗，返回原始內容:', error.message);
                    return jsonString;
                }
            }
        }

        /**
         * 驗證服務類別
         */
        class ValidationService {
            /**
             * 驗證 API Key
             * @param {string} apiKey - API Key
             * @returns {Object} 驗證結果 {isValid, message}
             */
            static validateApiKey(apiKey) {
                if (!Utils.isValidString(apiKey)) {
                    return {
                        isValid: false,
                        message: CONFIG.ERROR_MESSAGES.API_KEY_REQUIRED
                    };
                }

                // 可以加入更多 API Key 格式驗證
                const trimmedKey = apiKey.trim();
                if (trimmedKey.length < 10) { // 假設最小長度
                    return {
                        isValid: false,
                        message: 'API Key 格式不正確'
                    };
                }

                return {
                    isValid: true,
                    message: null
                };
            }

            /**
             * 驗證提示詞
             * @param {string} prompt - 提示詞
             * @returns {Object} 驗證結果 {isValid, message}
             */
            static validatePrompt(prompt) {
                if (!Utils.isValidString(prompt)) {
                    return {
                        isValid: false,
                        message: CONFIG.ERROR_MESSAGES.PROMPT_REQUIRED
                    };
                }

                const trimmedPrompt = prompt.trim();
                if (trimmedPrompt.length < 3) {
                    return {
                        isValid: false,
                        message: '提示詞至少需要 3 個字符'
                    };
                }

                // 移除字數限制，支援任何長度的提示詞（包括改善後的結構化提示詞）
                return {
                    isValid: true,
                    message: null
                };
            }

            /**
             * 驗證長寬比例
             * @param {string} aspectRatio - 長寬比例
             * @returns {Object} 驗證結果 {isValid, message}
             */
            static validateAspectRatio(aspectRatio) {
                const validRatios = Object.values(CONFIG.IMAGE.ASPECT_RATIOS);

                if (!validRatios.includes(aspectRatio)) {
                    return {
                        isValid: false,
                        message: '不支援的長寬比例'
                    };
                }

                return {
                    isValid: true,
                    message: null
                };
            }

            /**
             * 複合驗證 - 驗證所有必要輸入
             * @param {Object} inputs - 輸入物件 {apiKey, prompt, aspectRatio}
             * @returns {Object} 驗證結果 {isValid, message}
             */
            static validateAll(inputs) {
                const { apiKey, prompt, aspectRatio } = inputs;

                // 依序驗證
                const apiKeyResult = this.validateApiKey(apiKey);
                if (!apiKeyResult.isValid) {
                    return apiKeyResult;
                }

                const promptResult = this.validatePrompt(prompt);
                if (!promptResult.isValid) {
                    return promptResult;
                }

                const aspectRatioResult = this.validateAspectRatio(aspectRatio);
                if (!aspectRatioResult.isValid) {
                    return aspectRatioResult;
                }

                return {
                    isValid: true,
                    message: null
                };
            }

            /**
             * 驗證提示詞改善輸入
             * @param {string} prompt - 提示詞
             * @returns {Object} 驗證結果 {isValid, message}
             */
            static validatePromptForEnhancement(prompt) {
                if (!Utils.isValidString(prompt)) {
                    return {
                        isValid: false,
                        message: CONFIG.ERROR_MESSAGES.PROMPT_ENHANCE_REQUIRED
                    };
                }

                const trimmedPrompt = prompt.trim();
                if (trimmedPrompt.length < 2) {
                    return {
                        isValid: false,
                        message: '提示詞至少需要 2 個字符以進行改善'
                    };
                }

                return {
                    isValid: true,
                    message: null
                };
            }

            /**
             * 驗證 JSON 格式
             * @param {string} jsonString - JSON 字串
             * @returns {Object} 驗證結果 {isValid, message, data}
             */
            static validateJsonFormat(jsonString) {
                try {
                    const data = JSON.parse(jsonString);
                    return {
                        isValid: true,
                        message: null,
                        data: data
                    };
                } catch (error) {
                    return {
                        isValid: false,
                        message: 'JSON 格式錯誤',
                        data: null
                    };
                }
            }

            /**
             * 驗證 API 回應有效性
             * @param {Object} response - API 回應物件
             * @returns {Object} 驗證結果 {isValid, message}
             */
            static validateApiResponse(response) {
                if (!response || typeof response !== 'object') {
                    return {
                        isValid: false,
                        message: 'API 回應格式無效'
                    };
                }

                // 使用 PromptEnhancer 驗證結構
                if (!PromptEnhancer.validateJsonStructure(response)) {
                    return {
                        isValid: false,
                        message: '回應內容不完整或格式錯誤'
                    };
                }

                return {
                    isValid: true,
                    message: null
                };
            }

            /**
             * 檢測內容格式
             * @param {string} content - 要檢測的內容
             * @returns {string} 格式類型：'json', 'text', 'mixed'
             */
            static detectContentFormat(content) {
                if (!content || typeof content !== 'string') {
                    return 'text';
                }

                const trimmedContent = content.trim();

                // 檢查是否為純 JSON 格式
                if (this.isValidJsonContent(trimmedContent)) {
                    return 'json';
                }

                // 檢查是否為純文字格式
                if (this.isPlainTextContent(trimmedContent)) {
                    return 'text';
                }

                // 其他情況視為混合格式
                return 'mixed';
            }

            /**
             * 驗證是否為有效的 JSON 內容
             * @param {string} content - 要驗證的內容
             * @returns {boolean} 是否為有效 JSON
             */
            static isValidJsonContent(content) {
                if (!content || typeof content !== 'string') {
                    return false;
                }

                const trimmed = content.trim();
                if (!trimmed.startsWith('{') || !trimmed.endsWith('}')) {
                    return false;
                }

                try {
                    JSON.parse(trimmed);
                    return true;
                } catch (error) {
                    return false;
                }
            }

            /**
             * 檢測是否為純文字內容
             * @param {string} content - 要檢測的內容
             * @returns {boolean} 是否為純文字
             */
            static isPlainTextContent(content) {
                if (!content || typeof content !== 'string') {
                    return false;
                }

                const trimmed = content.trim();
                // 如果包含 JSON 結構標記，不視為純文字
                return !trimmed.includes('{') && !trimmed.includes('}') &&
                    !trimmed.includes('[') && !trimmed.includes(']');
            }

            /**
             * 檢測是否為混合內容
             * @param {string} content - 要檢測的內容
             * @returns {boolean} 是否為混合內容
             */
            static isMixedContent(content) {
                return this.detectContentFormat(content) === 'mixed';
            }

            /**
             * 驗證翻譯輸入內容
             * @param {string} content - 翻譯輸入內容
             * @returns {Object} 驗證結果 {isValid, message, format}
             */
            static validateTranslationInput(content) {
                if (!content || typeof content !== 'string') {
                    return {
                        isValid: false,
                        message: CONFIG.ERROR_MESSAGES.TRANSLATION_INPUT_INVALID,
                        format: null
                    };
                }

                const trimmed = content.trim();
                if (trimmed.length === 0) {
                    return {
                        isValid: false,
                        message: CONFIG.ERROR_MESSAGES.TRANSLATION_INPUT_INVALID,
                        format: null
                    };
                }

                const format = this.detectContentFormat(content);

                return {
                    isValid: true,
                    message: null,
                    format: format
                };
            }

            /**
             * 驗證翻譯輸出結果
             * @param {string} translatedContent - 翻譯後的內容
             * @param {string} originalFormat - 原始內容格式
             * @returns {Object} 驗證結果 {isValid, message}
             */
            static validateTranslationOutput(translatedContent, originalFormat) {
                if (!translatedContent || typeof translatedContent !== 'string') {
                    return {
                        isValid: false,
                        message: CONFIG.ERROR_MESSAGES.TRANSLATION_OUTPUT_INVALID
                    };
                }

                const trimmed = translatedContent.trim();
                if (trimmed.length === 0) {
                    return {
                        isValid: false,
                        message: CONFIG.ERROR_MESSAGES.TRANSLATION_OUTPUT_INVALID
                    };
                }

                // 如果原始內容是 JSON 格式，翻譯後也應該是 JSON 格式
                if (originalFormat === 'json' && !this.isValidJsonContent(trimmed)) {
                    return {
                        isValid: false,
                        message: '翻譯後的 JSON 格式不正確'
                    };
                }

                return {
                    isValid: true,
                    message: null
                };
            }
        }

        /**
         * 設定管理類別
         */
        class ConfigManager {
            constructor() {
                this.config = {
                    apiKey: null,
                    aspectRatio: CONFIG.IMAGE.DEFAULT_ASPECT_RATIO,
                    model: CONFIG.API.DEFAULT_MODEL,
                    autoTranslate: 'no',
                    uiLanguage: CONFIG.UI_LANGUAGE.DEFAULT
                };
                this.eventListeners = [];
            }

            /**
             * 載入所有儲存的設定
             */
            loadAllSettings() {
                this.config.apiKey = StorageService.loadApiKey();
                this.config.aspectRatio = StorageService.loadAspectRatio();
                this.config.model = StorageService.loadModelSelection();
                this.config.autoTranslate = StorageService.loadAutoTranslate();
                this.config.uiLanguage = StorageService.loadUILanguage();

                if (Utils.isDebugMode()) {
                    console.log('[ConfigManager] 所有設定載入完成:', this.config);
                }
                Logger.info('所有設定載入完成:', this.config);
                this.notifyConfigChange('load', this.config);
            }

            /**
             * 初始化預設設定
             */
            initializeDefaults() {
                if (!this.config.aspectRatio) {
                    this.config.aspectRatio = CONFIG.IMAGE.DEFAULT_ASPECT_RATIO;
                }
                if (!this.config.model) {
                    this.config.model = CONFIG.API.DEFAULT_MODEL;
                }
                if (!this.config.autoTranslate) {
                    this.config.autoTranslate = 'no';
                }
                if (!this.config.uiLanguage) {
                    this.config.uiLanguage = CONFIG.UI_LANGUAGE.DEFAULT;
                }
                Logger.info('預設設定初始化完成');
            }

            /**
             * 更新 API Key
             * @param {string} apiKey - 新的 API Key
             */
            updateApiKey(apiKey) {
                if (StorageService.saveApiKey(apiKey)) {
                    this.config.apiKey = apiKey;
                    this.notifyConfigChange('apiKey', apiKey);
                }
            }

            /**
             * 更新長寬比例
             * @param {string} aspectRatio - 新的長寬比例
             */
            updateAspectRatio(aspectRatio) {
                if (StorageService.saveAspectRatio(aspectRatio)) {
                    this.config.aspectRatio = aspectRatio;
                    this.notifyConfigChange('aspectRatio', aspectRatio);
                }
            }

            /**
             * 更新模型選擇
             * @param {string} model - 新的模型
             */
            updateModelSelection(model) {
                if (StorageService.saveModelSelection(model)) {
                    this.config.model = model;
                    this.notifyConfigChange('model', model);
                }
            }

            /**
             * 更新自動翻譯選項
             * @param {string} autoTranslate - 新的自動翻譯設定
             */
            updateAutoTranslate(autoTranslate) {
                if (StorageService.saveAutoTranslate(autoTranslate)) {
                    this.config.autoTranslate = autoTranslate;
                    if (Utils.isDebugMode()) {
                        console.log('[ConfigManager] 自動翻譯設定更新:', autoTranslate);
                    }
                    this.notifyConfigChange('autoTranslate', autoTranslate);
                }
            }

            /**
             * 取得當前設定
             * @returns {Object} 當前設定物件
             */
            getCurrentConfig() {
                return { ...this.config };
            }

            /**
             * 添加設定變更監聽器
             * @param {Function} listener - 監聽器函數
             */
            addConfigChangeListener(listener) {
                if (typeof listener === 'function') {
                    this.eventListeners.push(listener);
                }
            }

            /**
             * 移除設定變更監聽器
             * @param {Function} listener - 要移除的監聽器函數
             */
            removeConfigChangeListener(listener) {
                const index = this.eventListeners.indexOf(listener);
                if (index > -1) {
                    this.eventListeners.splice(index, 1);
                }
            }

            /**
             * 更新介面語言選擇
             * @param {string} uiLanguage - 新的介面語言
             */
            updateUILanguage(uiLanguage) {
                if (StorageService.saveUILanguage(uiLanguage)) {
                    this.config.uiLanguage = uiLanguage;
                    this.notifyConfigChange('uiLanguage', uiLanguage);
                }
            }

            /**
             * 通知設定變更
             * @param {string} type - 變更類型
             * @param {*} value - 變更的值
             */
            notifyConfigChange(type, value) {
                this.eventListeners.forEach(listener => {
                    try {
                        listener(type, value, this.config);
                    } catch (error) {
                        Logger.error('設定變更監聽器執行錯誤:', error);
                    }
                });
            }
        }

        /**
         * 圖片生成器類別 - 整合 IndexedDB 儲存功能
         */
        class ImageGenerator {
            constructor() {
                this.isGenerating = false;
                this.currentImageData = null;
                this.currentRecordId = null;
                this.indexedDBService = new IndexedDBService();
                this.thumbnailGenerator = ThumbnailGenerator;

                // 初始化資料庫
                this.initializeDatabase();
            }

            /**
             * 初始化資料庫
             */
            async initializeDatabase() {
                try {
                    await this.indexedDBService.initDatabase();
                    Logger.info('ImageGenerator 資料庫初始化成功');

                    // 執行自動清理
                    await this.indexedDBService.autoCleanup();
                } catch (error) {
                    Logger.error('資料庫初始化失敗:', error);
                }
            }

            /**
             * 生成並儲存圖片
             * @param {string} apiKey - API Key
             * @param {string} prompt - 提示詞 
             * @param {Object} options - 生成選項
             * @returns {Promise<string>} Base64 圖片資料
             */
            async generateImage(apiKey, prompt, options = {}) {
                // 防止重複生成
                if (this.isGenerating) {
                    throw new Error('圖片生成進行中，請稍候');
                }

                try {
                    this.isGenerating = true;

                    // 驗證輸入
                    const validationResult = ValidationService.validateAll({
                        apiKey,
                        prompt,
                        aspectRatio: options.aspectRatio || CONFIG.IMAGE.DEFAULT_ASPECT_RATIO
                    });

                    if (!validationResult.isValid) {
                        throw new Error(validationResult.message);
                    }

                    Logger.info('開始生成圖片:', { prompt, options });

                    // 調用 API 生成圖片
                    const imageData = await ApiClient.generateImage(apiKey, prompt, options);

                    // 生成縮圖
                    const thumbnailData = await this.thumbnailGenerator.generateThumbnail(imageData);

                    // 準備儲存記錄
                    // 如果有原始提示詞，使用原始提示詞保存；否則使用傳入的提示詞
                    const promptToSave = options.originalPrompt || prompt.trim();

                    const record = {
                        prompt: promptToSave,
                        imageData: imageData,
                        thumbnailData: thumbnailData,
                        aspectRatio: options.aspectRatio || CONFIG.IMAGE.DEFAULT_ASPECT_RATIO,
                        model: options.model || CONFIG.API.DEFAULT_MODEL,
                        generatedAt: new Date().toISOString()
                    };

                    // 儲存到 IndexedDB
                    const recordId = await this.indexedDBService.saveImageRecord(record);

                    // 更新當前狀態
                    this.currentImageData = imageData;
                    this.currentRecordId = recordId;

                    Logger.info('圖片生成並儲存成功，記錄 ID:', recordId);

                    if (Utils.isDebugMode() && options.originalPrompt) {
                        console.log('[ImageGenerator] 歷史記錄保存的原始提示詞:', promptToSave);
                    }

                    return imageData;

                } catch (error) {
                    Logger.error('圖片生成失敗:', error);
                    throw error;
                } finally {
                    this.isGenerating = false;
                }
            }

            /**
             * 從歷史記錄載入圖片
             * @param {number} recordId - 記錄 ID
             * @returns {Promise<Object>} 圖片記錄物件
             */
            async loadImageFromHistory(recordId) {
                try {
                    const records = await this.indexedDBService.loadImageHistory(0, 1000);
                    const record = records.find(r => r.id === recordId);

                    if (!record) {
                        throw new Error('找不到指定的歷史記錄');
                    }

                    // 更新當前狀態
                    this.currentImageData = record.imageData;
                    this.currentRecordId = recordId;

                    Logger.info('從歷史記錄載入圖片成功:', recordId);
                    return record;

                } catch (error) {
                    Logger.error('載入歷史圖片失敗:', error);
                    throw error;
                }
            }

            /**
             * 載入歷史記錄
             * @param {number} offset - 偏移量
             * @param {number} limit - 限制數量
             * @returns {Promise<Array>} 歷史記錄陣列
             */
            async loadHistory(offset = 0, limit = 20) {
                try {
                    return await this.indexedDBService.loadImageHistory(offset, limit);
                } catch (error) {
                    Logger.error('載入歷史記錄失敗:', error);
                    return [];
                }
            }

            /**
             * 檢查是否有歷史記錄
             * @returns {Promise<boolean>} 是否有歷史記錄
             */
            async hasHistory() {
                try {
                    const usage = await this.indexedDBService.getStorageUsage();
                    return usage.recordCount > 0;
                } catch (error) {
                    Logger.error('檢查歷史記錄失敗:', error);
                    return false;
                }
            }

            /**
             * 刪除歷史記錄
             * @param {number} recordId - 記錄 ID
             * @returns {Promise<boolean>} 刪除是否成功
             */
            async deleteHistoryRecord(recordId) {
                try {
                    const success = await this.indexedDBService.deleteImageRecord(recordId);

                    // 如果刪除的是當前圖片，清除當前狀態
                    if (recordId === this.currentRecordId) {
                        this.currentImageData = null;
                        this.currentRecordId = null;
                    }

                    Logger.info('歷史記錄刪除成功:', recordId);
                    return success;
                } catch (error) {
                    Logger.error('刪除歷史記錄失敗:', error);
                    return false;
                }
            }

            /**
             * 清空所有歷史記錄
             * @returns {Promise<boolean>} 清空是否成功
             */
            async clearAllHistory() {
                try {
                    const success = await this.indexedDBService.clearAllHistory();

                    // 清除當前狀態
                    this.currentImageData = null;
                    this.currentRecordId = null;

                    Logger.info('所有歷史記錄已清空');
                    return success;
                } catch (error) {
                    Logger.error('清空歷史記錄失敗:', error);
                    return false;
                }
            }

            /**
             * 取得儲存使用情況
             * @returns {Promise<Object>} 使用情況統計
             */
            async getStorageUsage() {
                try {
                    return await this.indexedDBService.getStorageUsage();
                } catch (error) {
                    Logger.error('取得儲存使用情況失敗:', error);
                    return { recordCount: 0, estimatedSize: 0, estimatedSizeMB: 0 };
                }
            }

            /**
             * 取得當前圖片資料
             * @returns {string|null} Base64 圖片資料
             */
            getCurrentImageData() {
                return this.currentImageData;
            }

            /**
             * 取得當前記錄 ID
             * @returns {number|null} 當前記錄 ID
             */
            getCurrentRecordId() {
                return this.currentRecordId;
            }

            /**
             * 清除當前圖片
             */
            clearCurrentImage() {
                this.currentImageData = null;
                this.currentRecordId = null;
                Logger.info('當前圖片已清除');
            }

            /**
             * 檢查是否正在生成
             * @returns {boolean} 是否正在生成
             */
            isCurrentlyGenerating() {
                return this.isGenerating;
            }

            /**
             * 取得 IndexedDB 服務實例
             * @returns {IndexedDBService} IndexedDB 服務實例
             */
            getIndexedDBService() {
                return this.indexedDBService;
            }

            // 為了向後相容，保留舊的方法
            /**
             * @deprecated 使用 clearAllHistory() 代替
             */
            clearHistory() {
                Logger.warn('clearHistory() 已棄用，請使用 clearAllHistory()');
                return this.clearAllHistory();
            }

            /**
             * @deprecated 使用 loadHistory() 代替
             */
            getHistory() {
                Logger.warn('getHistory() 已棄用，請使用 loadHistory()');
                return this.loadHistory();
            }
        }

        /**
         * 狀態管理類別
         */
        class StatusManager {
            constructor(statusElement, languageManager = null) {
                this.statusElement = statusElement;
                this.languageManager = languageManager;
                this.currentStatus = null;
                this.clearTimeout = null;
            }

            /**
             * 設定語言管理器
             * @param {LanguageManager} languageManager - 語言管理器實例
             */
            setLanguageManager(languageManager) {
                this.languageManager = languageManager;
            }

            /**
             * 獲取多語言訊息
             * @param {string} messageKey - 訊息鍵值
             * @param {string} fallbackMessage - 備用訊息
             * @returns {string} 對應語言的訊息
             */
            getMessage(messageKey, fallbackMessage = null) {
                if (!this.languageManager) {
                    return fallbackMessage || messageKey;
                }

                const message = this.languageManager.getUIText(messageKey, 'messages');
                return message !== messageKey ? message : (fallbackMessage || messageKey);
            }

            /**
             * 顯示狀態訊息
             * @param {string} message - 狀態訊息（可以是訊息鍵值或直接文字）
             * @param {string} type - 狀態類型 (info, success, error, loading)
             * @param {string} fallbackMessage - 備用訊息（當 message 是鍵值時使用）
             */
            showStatus(message, type = 'info', fallbackMessage = null) {
                // 清除之前的自動清除計時器
                if (this.clearTimeout) {
                    clearTimeout(this.clearTimeout);
                    this.clearTimeout = null;
                }

                // 嘗試獲取多語言訊息
                const displayMessage = this.getMessage(message, fallbackMessage || message);

                // 設定訊息和樣式
                this.statusElement.textContent = displayMessage;
                this.statusElement.className = `${CONSTANTS.CSS_CLASSES[`STATUS_${type.toUpperCase()}`]}`;

                // 顯示狀態區域
                this.statusElement.style.display = 'block';

                this.currentStatus = { message: displayMessage, type, timestamp: new Date() };

                Logger.info(`狀態更新: [${type.toUpperCase()}] ${displayMessage}`);

                // 自動清除邏輯：載入和錯誤狀態不自動清除，其他狀態3秒後清除
                if (type !== 'error' && type !== 'loading') {
                    this.clearTimeout = setTimeout(() => {
                        this.clearStatus();
                    }, CONFIG.TIMEOUTS.STATUS_CLEAR);
                }
            }

            /**
             * 顯示載入狀態
             * @param {string} messageKey - 載入訊息鍵值
             * @param {string} fallbackMessage - 備用訊息
             */
            showLoading(messageKey = 'loading', fallbackMessage = '處理中...') {
                this.showStatus(messageKey, 'loading', fallbackMessage);
            }

            /**
             * 顯示錯誤狀態
             * @param {string} messageKey - 錯誤訊息鍵值
             * @param {string} fallbackMessage - 備用訊息
             */
            showError(messageKey, fallbackMessage = null) {
                this.showStatus(messageKey, 'error', fallbackMessage);
            }

            /**
             * 顯示成功狀態
             * @param {string} messageKey - 成功訊息鍵值
             * @param {string} fallbackMessage - 備用訊息
             */
            showSuccess(messageKey, fallbackMessage = null) {
                this.showStatus(messageKey, 'success', fallbackMessage);
            }

            /**
             * 清除狀態訊息
             */
            clearStatus() {
                this.statusElement.textContent = '';
                this.statusElement.className = '';
                this.statusElement.style.display = 'none'; // 隱藏狀態區域
                this.currentStatus = null;

                if (this.clearTimeout) {
                    clearTimeout(this.clearTimeout);
                    this.clearTimeout = null;
                }
            }

            /**
             * 取得當前狀態
             * @returns {Object|null} 當前狀態物件
             */
            getCurrentStatus() {
                return this.currentStatus;
            }

            /**
             * 檢查是否有錯誤狀態
             * @returns {boolean} 是否為錯誤狀態
             */
            hasError() {
                return this.currentStatus && this.currentStatus.type === 'error';
            }

            /**
             * 檢查是否為載入狀態
             * @returns {boolean} 是否為載入狀態
             */
            isLoading() {
                return this.currentStatus && this.currentStatus.type === 'loading';
            }
        }

        /**
         * 圖片顯示類別
         */
        class ImageDisplay {
            constructor(containerElement, languageManager = null) {
                this.containerElement = containerElement;
                this.currentAspectRatio = CONFIG.IMAGE.DEFAULT_ASPECT_RATIO;
                this.hasImage = false;
                this.displayMode = 'single'; // 'single' 或 'grid'
                this.historyGridRenderer = new HistoryGridRenderer(languageManager);
                this.languageManager = languageManager;

                // 初始化手機版容器高度
                this.updateMobileContainerHeight(this.currentAspectRatio);

                // 綁定點擊事件
                this.bindClickEvent();
            }

            /**
             * 綁定圖片點擊事件
             */
            bindClickEvent() {
                this.containerElement.addEventListener('click', (event) => {
                    // 只有在有圖片且不在歷史模式時才處理點擊
                    if (this.hasImage && this.displayMode === 'single') {
                        this.handleImageClick(event);
                    }
                });
            }

            /**
             * 處理圖片點擊事件
             * @param {Event} event - 點擊事件
             */
            handleImageClick(event) {
                try {
                    const success = Utils.openImageFromElement(this.containerElement);

                    if (!success) {
                        // 顯示錯誤訊息
                        const errorMessage = this.languageManager ?
                            this.languageManager.getUIText('imageOpenFailed', 'messages') :
                            '無法開啟圖片，請稍後再試';

                        // 可以在這裡添加錯誤提示的顯示邏輯
                        Logger.error(errorMessage);
                    }
                } catch (error) {
                    Logger.error('處理圖片點擊事件時發生錯誤:', error);
                }
            }

            /**
             * 更新點擊提示文字
             */
            updateClickHint() {
                if (this.hasImage && this.languageManager) {
                    const hintText = this.languageManager.getUIText('imageOpenInNewTab', 'messages');
                    this.containerElement.setAttribute('data-click-hint', hintText);
                } else {
                    this.containerElement.removeAttribute('data-click-hint');
                }
            }

            /**
             * 顯示圖片
             * @param {string} base64Data - Base64 圖片資料
             */
            displayImage(base64Data) {
                if (!Utils.isValidString(base64Data)) {
                    Logger.error('無效的圖片資料');
                    return false;
                }

                try {
                    // 切換到單圖模式
                    this.switchToSingleMode();

                    // 建立 Data URL
                    const dataUrl = `data:${CONSTANTS.DOWNLOAD.MIME_TYPE};base64,${base64Data}`;

                    // 設定背景圖片
                    this.containerElement.style.backgroundImage = `url(${dataUrl})`;
                    this.containerElement.innerHTML = ''; // 清除預設文字

                    this.hasImage = true;

                    // 更新點擊提示
                    this.updateClickHint();

                    Logger.info('圖片顯示成功');
                    return true;

                } catch (error) {
                    Logger.error('顯示圖片時發生錯誤:', error);
                    return false;
                }
            }

            /**
             * 清除圖片
             */
            clearImage() {
                // 清除背景圖片
                this.containerElement.style.backgroundImage = '';

                // 調整容器尺寸到當前比例
                this.adjustContainerSize(this.currentAspectRatio);

                // 重新設置預設文字
                this.showDefaultContent();

                this.hasImage = false;

                // 移除點擊提示
                this.updateClickHint();

                Logger.info('圖片已清除');
            }

            /**
             * 顯示預設內容
             */
            showDefaultContent() {
                this.containerElement.innerHTML = `
                    <p style="text-align: center; margin: 0; color: #666; display: flex; align-items: center; justify-content: center; height: 100%;">
                        生成的圖片將顯示在這裡
                    </p>
                `;
            }

            /**
             * 顯示 Loading Bar
             */
            showLoadingBar() {
                this.containerElement.innerHTML = `
                    <div class="loading-container">
                        <div class="loader"></div>
                    </div>
                `;
                Logger.info('顯示載入動畫');
            }

            /**
             * 隱藏 Loading Bar（回復預設內容）
             */
            hideLoadingBar() {
                this.showDefaultContent();
                Logger.info('隱藏載入動畫');
            }

            /**
             * 顯示歷史網格
             */
            showHistoryGrid() {
                this.switchToGridMode();
                this.historyGridRenderer.showGrid();
            }

            /**
             * 隱藏歷史網格
             */
            hideHistoryGrid() {
                this.historyGridRenderer.hideGrid();
                this.switchToSingleMode();
            }

            /**
             * 切換到網格模式
             */
            switchToGridMode() {
                if (this.displayMode === 'grid') return;

                this.displayMode = 'grid';

                // 獲取右側面板（通過 ID 直接獲取，更可靠）
                const rightPanel = document.getElementById(CONSTANTS.DOM_IDS.RIGHT_PANEL);

                if (!rightPanel) {
                    Logger.error('找不到右側面板元素');
                    return;
                }

                // 初始化網格（在右側面板中）
                this.historyGridRenderer.renderGrid(rightPanel);
                this.historyGridRenderer.showGrid();

                Logger.info('已切換到網格模式');
            }

            /**
             * 切換到單圖模式
             */
            switchToSingleMode() {
                if (this.displayMode === 'single') return;

                this.displayMode = 'single';

                // 隱藏網格
                this.historyGridRenderer.hideGrid();

                // 恢復單圖顯示（如果沒有圖片，顯示預設文字）
                if (!this.hasImage) {
                    this.showDefaultContent();
                }

                Logger.info('已切換到單圖模式');
            }

            /**
             * 取得當前顯示模式
             * @returns {string} 顯示模式
             */
            getCurrentMode() {
                return this.displayMode;
            }

            /**
             * 是否為網格模式
             * @returns {boolean}
             */
            isGridMode() {
                return this.displayMode === 'grid';
            }

            /**
             * 載入歷史記錄到網格
             * @param {Array} records - 歷史記錄陣列
             * @param {number} selectedId - 選中的記錄 ID
             */
            loadHistoryToGrid(records, selectedId = null) {
                this.switchToGridMode();

                // 清空現有網格
                this.historyGridRenderer.clearGrid();

                // 添加記錄到網格
                records.forEach(record => {
                    const isSelected = record.id === selectedId;
                    this.historyGridRenderer.addThumbnailToGrid(record, isSelected);
                });

                // 如果有選中的記錄，高亮顯示
                if (selectedId) {
                    this.historyGridRenderer.highlightSelectedThumbnail(selectedId);
                }
            }

            /**
             * 添加更多歷史記錄到網格
             * @param {Array} records - 新的歷史記錄
             */
            appendHistoryToGrid(records) {
                records.forEach(record => {
                    this.historyGridRenderer.addThumbnailToGrid(record, false);
                });
            }

            /**
             * 高亮選中的縮圖
             * @param {number} recordId - 記錄 ID
             */
            highlightThumbnail(recordId) {
                this.historyGridRenderer.highlightSelectedThumbnail(recordId);
            }

            /**
             * 取得網格渲染器
             * @returns {HistoryGridRenderer}
             */
            getGridRenderer() {
                return this.historyGridRenderer;
            }

            /**
             * 調整容器尺寸
             * @param {string} aspectRatio - 長寬比例
             */
            adjustContainerSize(aspectRatio) {
                this.currentAspectRatio = aspectRatio;
                const maxSize = CONFIG.IMAGE.MAX_SIZE;

                let width, height;

                switch (aspectRatio) {
                    case CONFIG.IMAGE.ASPECT_RATIOS.SQUARE: // 1:1
                        width = height = maxSize;
                        break;
                    case CONFIG.IMAGE.ASPECT_RATIOS.PORTRAIT_9_16: // 9:16
                        width = Math.round(maxSize * 9 / 16);
                        height = maxSize;
                        break;
                    case CONFIG.IMAGE.ASPECT_RATIOS.LANDSCAPE_16_9: // 16:9
                        width = maxSize;
                        height = Math.round(maxSize * 9 / 16);
                        break;
                    case CONFIG.IMAGE.ASPECT_RATIOS.TRADITIONAL_LANDSCAPE: // 4:3
                        width = maxSize;
                        height = Math.round(maxSize * 3 / 4);
                        break;
                    case CONFIG.IMAGE.ASPECT_RATIOS.TRADITIONAL_PORTRAIT: // 3:4
                        width = Math.round(maxSize * 3 / 4);
                        height = maxSize;
                        break;
                    default:
                        width = height = maxSize;
                }

                // 應用尺寸（桌面版）
                this.containerElement.style.width = `${width}px`;
                this.containerElement.style.height = `${height}px`;
                this.containerElement.style.maxWidth = `${width}px`;
                this.containerElement.style.maxHeight = `${height}px`;

                // 手機版動態高度調整
                this.updateMobileContainerHeight(aspectRatio);

                Logger.info(`容器尺寸調整: ${aspectRatio} -> ${width}x${height}`);
            }

            /**
             * 更新手機版容器高度
             * @param {string} aspectRatio - 長寬比例
             */
            updateMobileContainerHeight(aspectRatio) {
                let heightCalc;

                switch (aspectRatio) {
                    case CONFIG.IMAGE.ASPECT_RATIOS.SQUARE: // 1:1
                        heightCalc = '100vw';
                        break;
                    case CONFIG.IMAGE.ASPECT_RATIOS.PORTRAIT_9_16: // 9:16
                        heightCalc = 'calc(100vw * 16 / 9)';
                        break;
                    case CONFIG.IMAGE.ASPECT_RATIOS.LANDSCAPE_16_9: // 16:9
                        heightCalc = 'calc(100vw * 9 / 16)';
                        break;
                    case CONFIG.IMAGE.ASPECT_RATIOS.TRADITIONAL_LANDSCAPE: // 4:3
                        heightCalc = 'calc(100vw * 3 / 4)';
                        break;
                    case CONFIG.IMAGE.ASPECT_RATIOS.TRADITIONAL_PORTRAIT: // 3:4
                        heightCalc = 'calc(100vw * 4 / 3)';
                        break;
                    default:
                        heightCalc = '100vw';
                }

                // 更新 CSS 自訂屬性
                document.documentElement.style.setProperty('--mobile-image-height', heightCalc);

                Logger.info(`手機版容器高度已更新: ${aspectRatio} -> ${heightCalc}`);
            }

            /**
             * 檢查是否有圖片
             * @returns {boolean} 是否有圖片
             */
            hasCurrentImage() {
                return this.hasImage;
            }

            /**
             * 取得當前長寬比例
             * @returns {string} 當前長寬比例
             */
            getCurrentAspectRatio() {
                return this.currentAspectRatio;
            }
        }

        /**
         * UI 控制器類別
         */
        class UIController {
            constructor(languageManager = null) {
                this.languageManager = languageManager;
                this.elements = {};
                this.eventListeners = [];
                this.cacheElements();
            }

            /**
             * 快取 DOM 元素
             */
            cacheElements() {
                const ids = Object.values(CONSTANTS.DOM_IDS);

                ids.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        this.elements[id] = element;
                    } else {
                        Logger.warn(`找不到元素: ${id}`);
                    }
                });

                Logger.info('DOM 元素快取完成:', Object.keys(this.elements));
            }

            /**
             * 取得快取的元素
             * @param {string} id - 元素 ID
             * @returns {HTMLElement|null} DOM 元素
             */
            getElement(id) {
                return this.elements[id] || null;
            }

            /**
             * 添加事件監聽器
             * @param {string} elementId - 元素 ID
             * @param {string} event - 事件名稱
             * @param {Function} handler - 事件處理函數
             */
            addEventListener(elementId, event, handler) {
                const element = this.getElement(elementId);
                if (element && typeof handler === 'function') {
                    element.addEventListener(event, handler);
                    this.eventListeners.push({ element, event, handler });
                    Logger.info(`事件監聽器已添加: ${elementId}.${event}`);
                } else {
                    Logger.warn(`無法添加事件監聽器: ${elementId}.${event}`);
                }
            }

            /**
             * 設定按鈕狀態
             * @param {string} buttonId - 按鈕 ID
             * @param {boolean} disabled - 是否禁用
             * @param {string} text - 按鈕文字 (可選)
             */
            setButtonState(buttonId, disabled, text = null) {
                const button = this.getElement(buttonId);
                if (button) {
                    button.disabled = disabled;
                    if (text !== null) {
                        button.textContent = text;
                    }
                    Logger.info(`按鈕狀態更新: ${buttonId} - disabled: ${disabled}, text: ${text}`);
                }
            }

            /**
             * 設定載入狀態
             * @param {boolean} isLoading - 是否載入中
             */
            setLoadingState(isLoading) {
                if (isLoading) {
                    // 禁用所有按鈕
                    this.setButtonState(CONSTANTS.DOM_IDS.ENHANCE_PROMPT_BTN, true);
                    this.setButtonState(CONSTANTS.DOM_IDS.GENERATE_BTN, true, '生成中...');
                    this.setButtonState(CONSTANTS.DOM_IDS.DOWNLOAD_BTN, true);
                    this.setButtonState(CONSTANTS.DOM_IDS.CLEAR_BTN, true);
                    this.setButtonState(CONSTANTS.DOM_IDS.HISTORY_BTN, true);

                    // 禁用左側輸入欄位
                    this.setInputFieldsState(true);
                } else {
                    // 恢復生成按鈕文字
                    this.setButtonState(CONSTANTS.DOM_IDS.GENERATE_BTN, false, '生成圖片');

                    // 恢復輸入欄位狀態
                    this.setInputFieldsState(false);

                    // 注意：其他按鈕的狀態應該由調用者透過 updateUIState 或其他方法來恢復
                    // 這裡不直接恢復其他按鈕狀態，避免覆蓋特定的業務邏輯
                }
            }

            /**
             * 設定輸入欄位狀態
             * @param {boolean} disabled - 是否禁用
             */
            setInputFieldsState(disabled) {
                const inputElements = [
                    CONSTANTS.DOM_IDS.API_KEY,
                    CONSTANTS.DOM_IDS.PROMPT,
                    CONSTANTS.DOM_IDS.PROMPT_LANGUAGE,
                    CONSTANTS.DOM_IDS.AUTO_TRANSLATE,
                    CONSTANTS.DOM_IDS.ASPECT_RATIO,
                    CONSTANTS.DOM_IDS.MODEL_SELECT
                ];

                inputElements.forEach(elementId => {
                    const element = this.getElement(elementId);
                    if (element) {
                        element.disabled = disabled;
                    }
                });

                if (Utils.isDebugMode()) {
                    console.log('[UIController] 輸入欄位狀態更新:', disabled);
                }
                Logger.info(`輸入欄位狀態更新: disabled: ${disabled}`);
            }

            /**
             * 設定下載按鈕狀態
             * @param {boolean} enabled - 是否啟用
             */
            setDownloadButtonState(enabled) {
                this.setButtonState(CONSTANTS.DOM_IDS.DOWNLOAD_BTN, !enabled);
            }

            /**
             * 設定歷史按鈕狀態
             * @param {boolean} enabled - 是否啟用
             * @param {string} mode - 模式 ('history' 或 'return')
             */
            setHistoryButtonState(enabled, mode = 'history') {
                const text = mode === 'history' ? '歷史紀錄' : '返回圖片';
                this.setButtonState(CONSTANTS.DOM_IDS.HISTORY_BTN, !enabled, text);
            }

            /**
             * 檢查提示詞並更新生成按鈕狀態
             */
            updateGenerateButtonState() {
                const prompt = this.getInputValue(CONSTANTS.DOM_IDS.PROMPT);
                const isPromptValid = Utils.isValidString(prompt);
                const currentMode = document.querySelector('.right-panel').classList.contains('history-mode') ? 'grid' : 'single';

                // 只在單圖模式下才需要檢查提示詞狀態
                if (currentMode === 'single') {
                    this.setButtonState(CONSTANTS.DOM_IDS.GENERATE_BTN, !isPromptValid);
                }
            }

            /**
             * 更新改善提示按鈕狀態
             */
            updateEnhancePromptButtonState() {
                const prompt = this.getInputValue(CONSTANTS.DOM_IDS.PROMPT);
                const isPromptValid = Utils.isValidString(prompt);
                const currentMode = document.querySelector('.right-panel').classList.contains('history-mode') ? 'grid' : 'single';

                // 只在單圖模式下才啟用改善提示按鈕
                if (currentMode === 'single') {
                    this.setButtonState(CONSTANTS.DOM_IDS.ENHANCE_PROMPT_BTN, !isPromptValid);
                }
            }

            /**
             * 更新提示詞相關按鈕狀態（生成按鈕和改善提示按鈕）
             */
            updatePromptRelatedButtonStates() {
                const prompt = this.getInputValue(CONSTANTS.DOM_IDS.PROMPT);
                const isPromptValid = Utils.isValidString(prompt);
                const currentMode = document.querySelector('.right-panel').classList.contains('history-mode') ? 'grid' : 'single';

                // 只在單圖模式下才需要檢查提示詞狀態
                if (currentMode === 'single') {
                    this.setButtonState(CONSTANTS.DOM_IDS.ENHANCE_PROMPT_BTN, !isPromptValid);
                    this.setButtonState(CONSTANTS.DOM_IDS.GENERATE_BTN, !isPromptValid);
                }
            }

            /**
             * 設定改善提示按鈕載入狀態
             * @param {boolean} isLoading - 是否載入中
             * @param {string} text - 按鈕文字
             */
            setEnhancePromptLoadingState(isLoading, text = null) {
                const buttonText = text || (isLoading ? '改善中...' : '改善提示');
                this.setButtonState(CONSTANTS.DOM_IDS.ENHANCE_PROMPT_BTN, isLoading, buttonText);

                if (isLoading) {
                    // 禁用所有其他按鈕
                    this.setButtonState(CONSTANTS.DOM_IDS.GENERATE_BTN, true);
                    this.setButtonState(CONSTANTS.DOM_IDS.DOWNLOAD_BTN, true);
                    this.setButtonState(CONSTANTS.DOM_IDS.CLEAR_BTN, true);
                    this.setButtonState(CONSTANTS.DOM_IDS.HISTORY_BTN, true);

                    // 禁用所有輸入欄位和選擇欄
                    this.setInputFieldsState(true);
                } else {
                    // 恢復所有按鈕和輸入欄位狀態

                    // 恢復輸入欄位
                    this.setInputFieldsState(false);

                    // 恢復按鈕狀態需要在外部處理，因為需要知道當前圖片和歷史狀態
                    // 這裡只恢復基本狀態，具體狀態由調用者處理
                }
            }

            /**
             * 設定翻譯載入狀態
             * @param {boolean} isLoading - 是否載入中
             * @param {string} text - 按鈕文字
             */
            setTranslationLoadingState(isLoading, text = null) {
                const buttonText = text || (isLoading ? '翻譯中...' : '生成圖片');
                this.setButtonState(CONSTANTS.DOM_IDS.GENERATE_BTN, isLoading, buttonText);

                if (isLoading) {
                    // 禁用所有其他按鈕
                    this.setButtonState(CONSTANTS.DOM_IDS.ENHANCE_PROMPT_BTN, true);
                    this.setButtonState(CONSTANTS.DOM_IDS.DOWNLOAD_BTN, true);
                    this.setButtonState(CONSTANTS.DOM_IDS.CLEAR_BTN, true);
                    this.setButtonState(CONSTANTS.DOM_IDS.HISTORY_BTN, true);

                    // 禁用所有輸入欄位和選擇欄
                    this.setInputFieldsState(true);
                } else {
                    // 恢復輸入欄位
                    this.setInputFieldsState(false);

                    // 按鈕狀態的恢復由調用者處理
                }
            }

            /**
             * 設定按鈕群組在不同模式下的狀態
             * @param {string} mode - 顯示模式 ('single' 或 'grid')
             * @param {boolean} hasImage - 是否有圖片
             * @param {boolean} hasHistory - 是否有歷史記錄
             */
            setButtonGroupState(mode, hasImage = false, hasHistory = false) {
                if (mode === 'grid') {
                    // 網格模式：只啟用歷史按鈕（作為返回按鈕）
                    this.setHistoryButtonState(true, 'return');
                    this.setButtonState(CONSTANTS.DOM_IDS.ENHANCE_PROMPT_BTN, true);
                    this.setButtonState(CONSTANTS.DOM_IDS.GENERATE_BTN, true);
                    this.setButtonState(CONSTANTS.DOM_IDS.DOWNLOAD_BTN, true);
                    this.setButtonState(CONSTANTS.DOM_IDS.CLEAR_BTN, true);
                } else {
                    // 單圖模式：根據狀態和提示詞內容啟用相應按鈕
                    this.setHistoryButtonState(hasHistory, 'history');

                    // 檢查提示詞是否有內容來決定生成按鈕和改善提示按鈕狀態
                    const prompt = this.getInputValue(CONSTANTS.DOM_IDS.PROMPT);
                    const isPromptValid = Utils.isValidString(prompt);

                    // 改善提示和生成按鈕：需要有效的提示詞才能啟用  
                    this.setButtonState(CONSTANTS.DOM_IDS.ENHANCE_PROMPT_BTN, !isPromptValid);
                    this.setButtonState(CONSTANTS.DOM_IDS.GENERATE_BTN, !isPromptValid);

                    // 下載和清除按鈕：需要有圖片才能啟用
                    this.setDownloadButtonState(hasImage);
                    this.setButtonState(CONSTANTS.DOM_IDS.CLEAR_BTN, !hasImage);
                }
            }

            /**
             * 取得輸入值
             * @param {string} elementId - 元素 ID
             * @returns {string} 輸入值
             */
            getInputValue(elementId) {
                const element = this.getElement(elementId);
                return element ? element.value.trim() : '';
            }

            /**
             * 設定輸入值
             * @param {string} elementId - 元素 ID
             * @param {string} value - 值
             */
            setInputValue(elementId, value) {
                const element = this.getElement(elementId);
                if (element) {
                    element.value = value;

                    // 如果是 textarea 且是提示詞元素，自動調整高度
                    if (element.tagName === 'TEXTAREA' && elementId === CONSTANTS.DOM_IDS.PROMPT) {
                        // 使用 setTimeout 確保值已設置完成後再調整高度
                        setTimeout(() => {
                            this.autoResizeTextarea(elementId);
                        }, 0);
                    }
                }
            }

            /**
             * 設定提示詞語言選擇框的值（已棄用，提示詞語言現自動跟隨介面語言）
             * @param {string} language - 語言代碼
             */
            setPromptLanguageValue(language) {
                // 此方法已棄用，提示詞語言現在自動跟隨介面語言
                if (Utils.isDebugMode()) {
                    console.log('[UIController] setPromptLanguageValue已棄用，提示詞語言自動跟隨介面語言');
                }
            }

            /**
             * 取得提示詞語言選擇框的值（現從LanguageManager取得）
             * @returns {string} 語言代碼
             */
            getPromptLanguageValue() {
                // 從LanguageManager取得當前提示詞語言
                const value = this.languageManager ? this.languageManager.getCurrentPromptLanguage() : 'en';
                if (Utils.isDebugMode()) {
                    console.log('[UIController] 取得提示詞語言:', value);
                }
                return value;
            }

            /**
             * 設定自動翻譯選擇框的值
             * @param {string} value - 自動翻譯設定 ('yes' 或 'no')
             */
            setAutoTranslateValue(value) {
                const element = this.getElement(CONSTANTS.DOM_IDS.AUTO_TRANSLATE);
                if (element) {
                    element.value = value;
                    if (Utils.isDebugMode()) {
                        console.log('[UIController] 自動翻譯設定為:', value);
                    }
                }
            }

            /**
             * 取得自動翻譯選擇框的值
             * @returns {string} 自動翻譯設定 ('yes' 或 'no')
             */
            getAutoTranslateValue() {
                const element = this.getElement(CONSTANTS.DOM_IDS.AUTO_TRANSLATE);
                const value = element ? element.value : 'no';
                if (Utils.isDebugMode()) {
                    console.log('[UIController] 取得自動翻譯設定:', value);
                }
                return value;
            }

            /**
             * 設定左側面板狀態（歷史模式）
             * @param {boolean} isHistoryMode - 是否為歷史模式
             */
            setLeftPanelState(isHistoryMode) {
                const leftPanel = document.querySelector('.left-panel');
                const inputElements = [
                    CONSTANTS.DOM_IDS.API_KEY,
                    CONSTANTS.DOM_IDS.PROMPT,
                    CONSTANTS.DOM_IDS.ASPECT_RATIO,
                    CONSTANTS.DOM_IDS.MODEL_SELECT
                ];

                if (isHistoryMode) {
                    // 添加歷史模式樣式類別
                    leftPanel?.classList.add('history-mode');

                    // 禁用所有輸入元素
                    inputElements.forEach(elementId => {
                        const element = this.getElement(elementId);
                        if (element) {
                            element.disabled = true;
                        }
                    });

                    Logger.info('左側面板已切換至歷史模式');
                } else {
                    // 移除歷史模式樣式類別
                    leftPanel?.classList.remove('history-mode');

                    // 啟用所有輸入元素
                    inputElements.forEach(elementId => {
                        const element = this.getElement(elementId);
                        if (element) {
                            element.disabled = false;
                        }
                    });

                    Logger.info('左側面板已切換至正常模式');
                }
            }

            /**
             * 處理鍵盤快捷鍵
             * @param {KeyboardEvent} event - 鍵盤事件
             * @param {Function} callback - 回調函數
             */
            handleKeyboardShortcut(event, callback) {
                if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
                    event.preventDefault();
                    if (typeof callback === 'function') {
                        callback();
                    }
                }
            }

            /**
             * 自動調整 textarea 高度
             * @param {string} elementId - textarea 元素 ID
             */
            autoResizeTextarea(elementId) {
                const textarea = this.getElement(elementId);
                if (!textarea || textarea.tagName !== 'TEXTAREA') {
                    return;
                }

                // 重置高度以計算實際需要的高度
                textarea.style.height = 'auto';

                // 計算內容所需的高度
                const scrollHeight = textarea.scrollHeight;
                const minHeight = 120; // 對應 CSS 中的 min-height

                // 設置新高度（至少為最小高度）
                const newHeight = Math.max(scrollHeight, minHeight);
                textarea.style.height = newHeight + 'px';

                Logger.info(`Textarea 高度已調整為: ${newHeight}px`);
            }

            /**
             * 設定介面語言選擇器的值
             * @param {string} language - 語言代碼
             */
            setUILanguageValue(language) {
                const element = this.getElement(CONSTANTS.DOM_IDS.UI_LANGUAGE);
                if (element && language) {
                    element.value = language;
                    if (Utils.isDebugMode()) {
                        console.log('[UIController] 介面語言設定為:', language);
                    }
                }
            }

            /**
             * 取得介面語言選擇器的值
             * @returns {string} 介面語言代碼
             */
            getUILanguageValue() {
                const element = this.getElement(CONSTANTS.DOM_IDS.UI_LANGUAGE);
                const value = element ? element.value : CONFIG.UI_LANGUAGE.DEFAULT;
                if (Utils.isDebugMode()) {
                    console.log('[UIController] 取得介面語言:', value);
                }
                return value;
            }

            /**
             * 清理所有事件監聽器
             */
            cleanup() {
                this.eventListeners.forEach(({ element, event, handler }) => {
                    element.removeEventListener(event, handler);
                });
                this.eventListeners = [];
                Logger.info('所有事件監聽器已清理');
            }
        }

        /**
         * 下載管理類別
         */
        class DownloadManager {
            /**
             * 下載圖片
             * @param {string} imageData - Base64 圖片資料
             * @param {string} aspectRatio - 長寬比例
             * @returns {boolean} 下載是否成功
             */
            static downloadImage(imageData, aspectRatio = CONFIG.IMAGE.DEFAULT_ASPECT_RATIO) {
                if (!Utils.isValidString(imageData)) {
                    Logger.error('沒有可下載的圖片資料');
                    throw new Error(CONFIG.ERROR_MESSAGES.NO_IMAGE_TO_DOWNLOAD);
                }

                try {
                    // 建立 Data URL
                    const dataUrl = `data:${CONSTANTS.DOWNLOAD.MIME_TYPE};base64,${imageData}`;

                    // 生成檔案名稱
                    const filename = this.generateFilename(aspectRatio);

                    // 建立並觸發下載
                    this.triggerDownload(dataUrl, filename);

                    Logger.info('圖片下載成功:', filename);
                    return true;

                } catch (error) {
                    Logger.error('下載圖片時發生錯誤:', error);
                    throw new Error(`下載圖片時發生錯誤: ${error.message}`);
                }
            }

            /**
             * 生成檔案名稱
             * @param {string} aspectRatio - 長寬比例
             * @returns {string} 檔案名稱
             */
            static generateFilename(aspectRatio) {
                return Utils.generateFilename(
                    CONSTANTS.DOWNLOAD.FILE_PREFIX,
                    aspectRatio,
                    CONSTANTS.DOWNLOAD.FILE_EXTENSION
                );
            }

            /**
             * 觸發下載
             * @param {string} dataUrl - 資料 URL
             * @param {string} filename - 檔案名稱
             */
            static triggerDownload(dataUrl, filename) {
                // 建立隱藏的下載連結
                const link = document.createElement('a');
                link.href = dataUrl;
                link.download = filename;
                link.style.display = 'none';

                // 添加到文件，觸發下載，然後移除
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            /**
             * 檢查瀏覽器下載支援
             * @returns {boolean} 是否支援下載
             */
            static isDownloadSupported() {
                const link = document.createElement('a');
                return typeof link.download !== 'undefined';
            }
        }

        /**
         * Gemini 圖片生成器主類別
         */
        class GeminiImageGenerator {
            constructor() {
                // 初始化語言管理器（優先初始化，因為其他服務可能需要語言資訊）
                this.languageManager = new LanguageManager();

                // 初始化所有服務
                this.configManager = new ConfigManager();
                this.imageGenerator = new ImageGenerator();
                this.uiController = new UIController(this.languageManager);
                this.statusManager = new StatusManager(this.uiController.getElement(CONSTANTS.DOM_IDS.STATUS), this.languageManager);
                this.imageDisplay = new ImageDisplay(this.uiController.getElement(CONSTANTS.DOM_IDS.IMAGE_CONTAINER), this.languageManager);

                // 設定 StatusManager 的 LanguageManager
                this.statusManager.setLanguageManager(this.languageManager);

                // 歷史功能狀態
                this.currentHistoryOffset = 0;
                this.hasMoreHistory = true;
                this.isLoadingHistory = false;

                // 初始化應用程式
                this.init();
            }

            /**
             * 根據設備類型動態計算歷史記錄頁面大小
             * @returns {number} 頁面大小
             */
            getHistoryPageSize() {
                // 檢查是否為手機版 (螢幕寬度 <= 480px)
                const isMobile = window.innerWidth <= 480;
                return isMobile ? 5 : 20; // 手機版 5 張，桌機版 20 張
            }

            /**
             * 初始化應用程式
             */
            async init() {
                try {
                    // 載入設定
                    this.configManager.loadAllSettings();
                    this.configManager.initializeDefaults();

                    // 設定 UI 初始狀態
                    await this.setupInitialUI();

                    // 綁定事件監聽器
                    this.bindEventListeners();

                    // 添加設定變更監聽器
                    this.configManager.addConfigChangeListener((type, value) => {
                        this.handleConfigChange(type, value);
                    });

                    Logger.info('Gemini Image Generator 初始化完成');
                    Logger.info(`當前語言: ${this.languageManager.getCurrentLanguage()}`);

                } catch (error) {
                    Logger.error('初始化失敗:', error);
                    this.statusManager.showError('appInitFailed', '應用程式初始化失敗');
                }
            }

            /**
             * 設定初始 UI 狀態
             */
            async setupInitialUI() {
                const config = this.configManager.getCurrentConfig();

                // 設定輸入值
                if (config.apiKey) {
                    this.uiController.setInputValue(CONSTANTS.DOM_IDS.API_KEY, config.apiKey);
                }
                this.uiController.setInputValue(CONSTANTS.DOM_IDS.ASPECT_RATIO, config.aspectRatio);
                this.uiController.setInputValue(CONSTANTS.DOM_IDS.MODEL_SELECT, config.model);

                // 設定自動翻譯選擇框初始值
                this.uiController.setAutoTranslateValue(config.autoTranslate);

                // 設定介面語言選擇框初始值
                this.uiController.setUILanguageValue(this.languageManager.getCurrentUILanguage());

                // 初始化介面語言
                this.languageManager.updateInterface(this.languageManager.getCurrentUILanguage());

                if (Utils.isDebugMode()) {
                    console.log('[GeminiImageGenerator] 初始化提示詞語言（自動跟隨介面語言）:', this.languageManager.getCurrentPromptLanguage());
                    console.log('[GeminiImageGenerator] 初始化自動翻譯設定:', config.autoTranslate);
                    console.log('[GeminiImageGenerator] 初始化介面語言:', this.languageManager.getCurrentUILanguage());
                }

                // 調整圖片容器尺寸
                this.imageDisplay.adjustContainerSize(config.aspectRatio);

                // 檢查是否有歷史記錄
                const hasHistory = await this.imageGenerator.hasHistory();

                // 初始化按鈕狀態：
                // - 歷史紀錄按鈕：根據是否有歷史記錄決定
                // - 其他按鈕：初始時都應該是禁用狀態（沒有圖片，沒有提示詞）
                this.uiController.setHistoryButtonState(hasHistory, 'history');
                this.uiController.setButtonState(CONSTANTS.DOM_IDS.ENHANCE_PROMPT_BTN, true); // 禁用
                this.uiController.setButtonState(CONSTANTS.DOM_IDS.GENERATE_BTN, true); // 禁用
                this.uiController.setButtonState(CONSTANTS.DOM_IDS.DOWNLOAD_BTN, true); // 禁用
                this.uiController.setButtonState(CONSTANTS.DOM_IDS.CLEAR_BTN, true); // 禁用

                // 初始化時調整 textarea 高度
                this.uiController.autoResizeTextarea(CONSTANTS.DOM_IDS.PROMPT);
            }

            /**
             * 更新 UI 狀態
             * @param {boolean} hasHistory - 是否有歷史記錄
             */
            updateUIState(hasHistory = false) {
                const currentMode = this.imageDisplay.getCurrentMode();
                const hasCurrentImage = this.imageDisplay.hasCurrentImage();

                this.uiController.setButtonGroupState(currentMode, hasCurrentImage, hasHistory);
            }

            /**
             * 綁定事件監聽器
             */
            bindEventListeners() {
                // 按鈕事件
                this.uiController.addEventListener(CONSTANTS.DOM_IDS.ENHANCE_PROMPT_BTN, CONSTANTS.EVENTS.CLICK, () => {
                    this.handleEnhancePrompt();
                });

                this.uiController.addEventListener(CONSTANTS.DOM_IDS.GENERATE_BTN, CONSTANTS.EVENTS.CLICK, () => {
                    this.handleGenerateImage();
                });

                this.uiController.addEventListener(CONSTANTS.DOM_IDS.DOWNLOAD_BTN, CONSTANTS.EVENTS.CLICK, () => {
                    this.handleDownloadImage();
                });

                this.uiController.addEventListener(CONSTANTS.DOM_IDS.CLEAR_BTN, CONSTANTS.EVENTS.CLICK, () => {
                    this.handleClearImage();
                });

                // 歷史按鈕事件
                this.uiController.addEventListener(CONSTANTS.DOM_IDS.HISTORY_BTN, CONSTANTS.EVENTS.CLICK, () => {
                    this.handleHistoryToggle();
                });

                // 縮圖點擊事件
                document.addEventListener('thumbnailClick', (event) => {
                    this.handleThumbnailClick(event.detail.recordId);
                });

                // 載入更多按鈕事件（動態綁定）
                document.addEventListener('click', (event) => {
                    if (event.target.id === CONSTANTS.DOM_IDS.LOAD_MORE_BTN) {
                        this.handleLoadMoreHistory();
                    }
                });

                // 設定變更事件
                this.uiController.addEventListener(CONSTANTS.DOM_IDS.API_KEY, CONSTANTS.EVENTS.BLUR, () => {
                    const apiKey = this.uiController.getInputValue(CONSTANTS.DOM_IDS.API_KEY);
                    this.configManager.updateApiKey(apiKey);
                });

                // 提示詞輸入事件 - 即時檢查並更新按鈕狀態，同時自動調整高度
                this.uiController.addEventListener(CONSTANTS.DOM_IDS.PROMPT, 'input', () => {
                    this.uiController.updatePromptRelatedButtonStates();
                    this.uiController.autoResizeTextarea(CONSTANTS.DOM_IDS.PROMPT);
                });

                this.uiController.addEventListener(CONSTANTS.DOM_IDS.ASPECT_RATIO, CONSTANTS.EVENTS.CHANGE, () => {
                    const aspectRatio = this.uiController.getInputValue(CONSTANTS.DOM_IDS.ASPECT_RATIO);
                    this.configManager.updateAspectRatio(aspectRatio);
                });

                this.uiController.addEventListener(CONSTANTS.DOM_IDS.MODEL_SELECT, CONSTANTS.EVENTS.CHANGE, () => {
                    const model = this.uiController.getInputValue(CONSTANTS.DOM_IDS.MODEL_SELECT);
                    this.configManager.updateModelSelection(model);
                });

                // 自動翻譯選擇事件
                this.uiController.addEventListener(CONSTANTS.DOM_IDS.AUTO_TRANSLATE, CONSTANTS.EVENTS.CHANGE, () => {
                    const autoTranslate = this.uiController.getAutoTranslateValue();
                    this.configManager.updateAutoTranslate(autoTranslate);

                    if (Utils.isDebugMode()) {
                        console.log('[GeminiImageGenerator] 自動翻譯設定變更:', autoTranslate);
                    }
                });

                // 介面語言選擇事件
                this.uiController.addEventListener(CONSTANTS.DOM_IDS.UI_LANGUAGE, CONSTANTS.EVENTS.CHANGE, () => {
                    const uiLanguage = this.uiController.getUILanguageValue();
                    this.handleUILanguageChange(uiLanguage);

                    if (Utils.isDebugMode()) {
                        console.log('[GeminiImageGenerator] 介面語言變更:', uiLanguage);
                    }
                });

                // 鍵盤快捷鍵
                const promptElement = this.uiController.getElement(CONSTANTS.DOM_IDS.PROMPT);
                if (promptElement) {
                    promptElement.addEventListener(CONSTANTS.EVENTS.KEYDOWN, (e) => {
                        this.uiController.handleKeyboardShortcut(e, () => {
                            this.handleGenerateImage();
                        });
                    });
                }

                // 全域鍵盤快捷鍵
                document.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() === 'h' && !e.ctrlKey && !e.metaKey && !e.altKey) {
                        // 檢查是否在輸入框中
                        if (document.activeElement.tagName !== 'INPUT' &&
                            document.activeElement.tagName !== 'TEXTAREA') {
                            e.preventDefault();
                            this.handleHistoryToggle();
                        }
                    }
                });

                // 窗口大小變化監聽器 - 用於響應式調整
                this.resizeTimeout = null;
                window.addEventListener('resize', () => {
                    // 使用防抖動技術，避免過於頻繁的調整
                    if (this.resizeTimeout) {
                        clearTimeout(this.resizeTimeout);
                    }
                    this.resizeTimeout = setTimeout(() => {
                        this.handleWindowResize();
                    }, 250);
                });
            }

            /**
             * 處理歷史模式切換
             */
            async handleHistoryToggle() {
                try {
                    const currentMode = this.imageDisplay.getCurrentMode();

                    if (currentMode === 'single') {
                        // 切換到歷史模式
                        await this.showHistoryGrid();
                    } else {
                        // 返回單圖模式
                        this.hideHistoryGrid();
                    }

                } catch (error) {
                    Logger.error('切換歷史模式失敗:', error);
                    this.statusManager.showError('historyToggleFailed', '切換歷史模式失敗');
                }
            }

            /**
             * 處理窗口大小變化
             */
            handleWindowResize() {
                try {
                    // 調整圖片容器尺寸（如果有當前顯示的圖片）
                    if (this.imageDisplay.hasCurrentImage()) {
                        const currentAspectRatio = this.imageDisplay.getCurrentAspectRatio();
                        this.imageDisplay.adjustContainerSize(currentAspectRatio);
                    }

                    // 如果當前是網格模式，重新渲染縮圖以適應新的屏幕尺寸
                    if (this.imageDisplay.isGridMode()) {
                        this.refreshHistoryGrid();
                    }

                    Logger.info('窗口大小調整完成');
                } catch (error) {
                    Logger.error('窗口大小調整失敗:', error);
                }
            }

            /**
             * 刷新歷史網格
             */
            async refreshHistoryGrid() {
                try {
                    const gridRenderer = this.imageDisplay.getGridRenderer();

                    // 清空現有網格
                    gridRenderer.clearGrid();

                    // 重新載入當前已載入的歷史記錄
                    const records = await this.imageGenerator.loadHistory(0, this.currentHistoryOffset + this.getHistoryPageSize());
                    const selectedId = this.imageGenerator.getCurrentRecordId();

                    this.imageDisplay.loadHistoryToGrid(records, selectedId);

                    Logger.info('歷史網格刷新完成');
                } catch (error) {
                    Logger.error('刷新歷史網格失敗:', error);
                }
            }

            /**
             * 顯示歷史網格
             */
            async showHistoryGrid() {
                try {
                    // 只在 debug 模式下顯示載入訊息
                    if (Utils.isDebugMode()) {
                        console.log('[GeminiImageGenerator] 載入歷史記錄...');
                    }

                    // 重設分頁狀態
                    this.currentHistoryOffset = 0;
                    this.hasMoreHistory = true;

                    // 載入歷史記錄
                    const records = await this.imageGenerator.loadHistory(0, this.getHistoryPageSize());

                    if (records.length === 0) {
                        this.statusManager.showStatus(this.languageManager.getUIText('noHistory', 'messages'), 'info');
                        return;
                    }

                    // 顯示網格並載入記錄
                    const currentRecordId = this.imageGenerator.getCurrentRecordId();
                    this.imageDisplay.loadHistoryToGrid(records, currentRecordId);

                    // 更新分頁狀態
                    this.currentHistoryOffset = records.length;
                    this.hasMoreHistory = records.length === this.getHistoryPageSize();

                    Logger.info('載入歷史記錄:', {
                        loaded: records.length,
                        pageSize: this.getHistoryPageSize(),
                        hasMore: this.hasMoreHistory,
                        offset: this.currentHistoryOffset
                    });

                    // 顯示/隱藏載入更多按鈕
                    const gridRenderer = this.imageDisplay.getGridRenderer();
                    if (this.hasMoreHistory) {
                        Logger.info('顯示載入更多按鈕 - 還有更多記錄');
                        gridRenderer.showLoadMoreButton();
                    } else {
                        Logger.info('隱藏載入更多按鈕 - 沒有更多記錄');
                        gridRenderer.hideLoadMoreButton();
                    }

                    // 設定左側面板為歷史模式（禁用輸入）
                    this.uiController.setLeftPanelState(true);

                    // 更新 UI 狀態
                    this.updateUIState(true);
                    this.statusManager.showStatus(this.languageManager.getUIText('historyLoadSuccess', 'messages'), 'success');

                } catch (error) {
                    Logger.error('載入歷史記錄失敗:', error);
                    this.statusManager.showError('historyLoadFailed', '載入歷史記錄失敗');
                }
            }

            /**
             * 隱藏歷史網格
             */
            hideHistoryGrid() {
                this.imageDisplay.hideHistoryGrid();

                // 恢復左側面板為正常模式（啟用輸入）
                this.uiController.setLeftPanelState(false);

                this.updateUIState(true);

                // 恢復到單圖模式後，重新檢查生成按鈕狀態
                this.uiController.updateGenerateButtonState();

                // 如果有當前圖片，顯示成功訊息
                if (this.imageDisplay.hasCurrentImage()) {
                    this.statusManager.showStatus(this.languageManager.getUIText('backToImageDisplay', 'messages'), 'info');
                }
            }

            /**
             * 處理縮圖點擊
             * @param {number} recordId - 記錄 ID
             */
            async handleThumbnailClick(recordId) {
                try {
                    this.statusManager.showStatus(this.languageManager.getUIText('loadingImage', 'messages'), 'loading');

                    // 從歷史記錄載入圖片
                    const record = await this.imageGenerator.loadImageFromHistory(recordId);

                    // 顯示圖片
                    this.imageDisplay.displayImage(record.imageData);

                    // 自動填入表單
                    this.loadHistoryToForm(record);

                    // 切換回單圖模式
                    this.hideHistoryGrid();

                    // 更新 UI 狀態
                    this.updateUIState(true);
                    this.statusManager.showStatus(this.languageManager.getUIText('imageLoadSuccess', 'messages'), 'success');

                } catch (error) {
                    Logger.error('載入歷史圖片失敗:', error);
                    this.statusManager.showStatus(this.languageManager.getUIText('imageLoadFailed', 'messages'), 'error');
                }
            }

            /**
             * 載入歷史記錄到表單
             * @param {Object} record - 歷史記錄
             */
            loadHistoryToForm(record) {
                // 填入提示詞
                this.uiController.setInputValue(CONSTANTS.DOM_IDS.PROMPT, record.prompt);

                // 設定長寬比例
                if (record.aspectRatio) {
                    this.uiController.setInputValue(CONSTANTS.DOM_IDS.ASPECT_RATIO, record.aspectRatio);
                    this.configManager.updateAspectRatio(record.aspectRatio);
                }

                // 設定模型
                if (record.model) {
                    this.uiController.setInputValue(CONSTANTS.DOM_IDS.MODEL_SELECT, record.model);
                    this.configManager.updateModelSelection(record.model);
                }

                // 啟用下載按鈕
                this.uiController.setDownloadButtonState(true);

                // 更新生成按鈕狀態（因為提示詞已填入，應該啟用）
                this.uiController.updateGenerateButtonState();

                Logger.info('歷史記錄已載入到表單');
            }

            /**
             * 處理載入更多歷史記錄
             */
            async handleLoadMoreHistory() {
                if (this.isLoadingHistory || !this.hasMoreHistory) {
                    return;
                }

                try {
                    this.isLoadingHistory = true;
                    const gridRenderer = this.imageDisplay.getGridRenderer();
                    gridRenderer.setLoadMoreButtonState(true);

                    // 載入更多記錄
                    const records = await this.imageGenerator.loadHistory(
                        this.currentHistoryOffset,
                        this.getHistoryPageSize()
                    );

                    if (records.length > 0) {
                        // 添加到現有網格
                        this.imageDisplay.appendHistoryToGrid(records);

                        // 更新分頁狀態
                        this.currentHistoryOffset += records.length;
                        this.hasMoreHistory = records.length === this.getHistoryPageSize();

                        Logger.info(`載入了額外 ${records.length} 筆歷史記錄`);
                    } else {
                        this.hasMoreHistory = false;
                    }

                    // 顯示/隱藏載入更多按鈕
                    if (this.hasMoreHistory) {
                        gridRenderer.setLoadMoreButtonState(false);
                    } else {
                        gridRenderer.hideLoadMoreButton();
                    }

                } catch (error) {
                    Logger.error('載入更多歷史記錄失敗:', error);
                    this.statusManager.showStatus(this.languageManager.getUIText('loadMoreFailed', 'messages'), 'error');
                } finally {
                    this.isLoadingHistory = false;
                }
            }

            /**
             * 處理設定變更
             * @param {string} type - 變更類型
             * @param {*} value - 變更值
             */
            handleConfigChange(type, value) {
                switch (type) {
                    case 'aspectRatio':
                        this.imageDisplay.adjustContainerSize(value);
                        break;
                    case 'uiLanguage':
                        // 介面語言變更已在 handleUILanguageChange 中處理
                        break;
                    default:
                        Logger.info(`設定變更: ${type} = ${value}`);
                }
            }

            /**
             * 處理介面語言變更
             * @param {string} uiLanguage - 新的介面語言
             */
            handleUILanguageChange(uiLanguage) {
                try {
                    // 更新語言管理器
                    if (this.languageManager.switchUILanguage(uiLanguage)) {
                        // 更新配置管理器
                        this.configManager.updateUILanguage(uiLanguage);

                        // 更新圖片點擊提示文字
                        if (this.imageDisplay) {
                            this.imageDisplay.updateClickHint();
                        }

                        Logger.info(`介面語言已切換至: ${uiLanguage}`);

                        // 顯示切換成功訊息（使用新語言）
                        const successMessage = this.languageManager.getUIText('languageChanged', 'messages') || '語言已切換';
                        this.statusManager.showStatus(successMessage, 'success');
                    } else {
                        Logger.error(`介面語言切換失敗: ${uiLanguage}`);
                        this.statusManager.showError('languageChangeFailed', '語言切換失敗');
                    }
                } catch (error) {
                    Logger.error('處理介面語言變更時發生錯誤:', error);
                    this.statusManager.showError('languageChangeFailed', '語言切換失敗');
                }
            }

            /**
             * 處理改善提示
             */
            async handleEnhancePrompt() {
                try {
                    // 取得輸入值
                    const apiKey = this.uiController.getInputValue(CONSTANTS.DOM_IDS.API_KEY);
                    const prompt = this.uiController.getInputValue(CONSTANTS.DOM_IDS.PROMPT);
                    const promptLanguage = this.uiController.getPromptLanguageValue();

                    if (Utils.isDebugMode()) {
                        console.log('[GeminiImageGenerator] 開始改善提示詞:', { prompt, promptLanguage });
                    }

                    // 驗證輸入
                    const apiKeyValidation = ValidationService.validateApiKey(apiKey);
                    if (!apiKeyValidation.isValid) {
                        this.statusManager.showStatus(apiKeyValidation.message, 'error');
                        return;
                    }

                    const promptValidation = ValidationService.validatePromptForEnhancement(prompt);
                    if (!promptValidation.isValid) {
                        this.statusManager.showStatus(promptValidation.message, 'error');
                        return;
                    }

                    // 設定載入狀態
                    this.uiController.setEnhancePromptLoadingState(true);
                    this.statusManager.showStatus(this.languageManager.getUIText('enhancingPrompt', 'messages'), 'loading');

                    // 嘗試改善提示詞，包含重試邏輯
                    let enhancedData;
                    let retryCount = 0;
                    const maxRetries = 2;

                    while (retryCount <= maxRetries) {
                        try {
                            // 調用 API 改善提示詞
                            enhancedData = await ApiClient.enhancePrompt(apiKey, prompt, promptLanguage);

                            // 驗證回應
                            const responseValidation = ValidationService.validateApiResponse(enhancedData);
                            if (!responseValidation.isValid) {
                                throw new Error(responseValidation.message);
                            }

                            // 驗證語言是否符合選擇
                            const languageValid = ApiClient.validateResponseLanguage(enhancedData, promptLanguage);

                            if (!languageValid && retryCount < maxRetries) {
                                // 語言不符且還有重試機會，詢問用戶是否重試
                                const shouldRetry = await ApiClient.handleLanguageMismatch(promptLanguage, this.languageManager);

                                if (shouldRetry) {
                                    retryCount++;
                                    this.statusManager.showStatus(this.languageManager.getUIText('languageMismatchRetry', 'messages') + ` (${retryCount}/${maxRetries})`, 'loading');
                                    continue;
                                }
                            }

                            // 成功或用戶選擇不重試，跳出循環
                            break;

                        } catch (error) {
                            // API 錯誤，如果還有重試機會且用戶願意重試
                            if (retryCount < maxRetries) {
                                const confirmMessage = this.languageManager.getUIText('confirmRetryEnhance', 'messages').replace('{0}', error.message);
                                const shouldRetry = window.confirm(confirmMessage);
                                if (shouldRetry) {
                                    retryCount++;
                                    this.statusManager.showStatus(this.languageManager.getUIText('retrying', 'messages') + ` (${retryCount}/${maxRetries})`, 'loading');
                                    continue;
                                }
                            }
                            throw error;
                        }
                    }

                    // 轉換為可讀提示詞
                    const readablePrompt = PromptEnhancer.jsonToReadablePrompt(enhancedData);

                    // 更新提示詞文字框
                    this.uiController.setInputValue(CONSTANTS.DOM_IDS.PROMPT, readablePrompt);

                    this.statusManager.showStatus(this.languageManager.getUIText('promptEnhanceSuccess', 'messages'), 'success');

                } catch (error) {
                    Logger.error('改善提示詞失敗:', error);
                    this.statusManager.showStatus(error.message, 'error');
                } finally {
                    // 恢復按鈕和輸入欄位狀態
                    this.uiController.setEnhancePromptLoadingState(false);

                    // 恢復其他按鈕狀態
                    const hasHistory = await this.imageGenerator.hasHistory();
                    this.updateUIState(hasHistory);

                    // 更新生成和改善提示按鈕狀態（因為提示詞內容可能已改變）
                    this.uiController.updatePromptRelatedButtonStates();
                }
            }

            /**
             * 處理生成圖片
             */
            async handleGenerateImage() {
                try {
                    // 檢查是否正在生成
                    if (this.imageGenerator.isCurrentlyGenerating()) {
                        this.statusManager.showStatus(this.languageManager.getUIText('imageGenerationInProgress', 'messages'), 'info');
                        return;
                    }

                    // 取得輸入值
                    const apiKey = this.uiController.getInputValue(CONSTANTS.DOM_IDS.API_KEY);
                    const prompt = this.uiController.getInputValue(CONSTANTS.DOM_IDS.PROMPT);
                    const aspectRatio = this.uiController.getInputValue(CONSTANTS.DOM_IDS.ASPECT_RATIO);
                    const model = this.uiController.getInputValue(CONSTANTS.DOM_IDS.MODEL_SELECT);
                    const config = this.configManager.getCurrentConfig();

                    // 驗證輸入
                    const validation = ValidationService.validateAll({ apiKey, prompt, aspectRatio });
                    if (!validation.isValid) {
                        this.statusManager.showStatus(validation.message, 'error');
                        return;
                    }

                    // 檢查是否需要自動翻譯
                    let finalPrompt = prompt;
                    if (config.autoTranslate === 'yes') {
                        // 需要翻譯
                        finalPrompt = await this.handlePromptTranslation(apiKey, prompt);
                        if (!finalPrompt) {
                            // 翻譯失敗或用戶取消
                            return;
                        }
                    }

                    // 設定載入狀態
                    this.uiController.setLoadingState(true);
                    this.statusManager.showStatus(this.languageManager.getUIText('imageGenerating', 'messages'), 'loading');

                    // 顯示 loading bar
                    this.imageDisplay.showLoadingBar();

                    // 生成圖片（會自動儲存到 IndexedDB）
                    // 注意：儲存的是原始提示詞，不是翻譯後的
                    const imageData = await this.imageGenerator.generateImage(apiKey, finalPrompt, {
                        aspectRatio,
                        model,
                        originalPrompt: prompt // 傳遞原始提示詞用於歷史記錄
                    });

                    // 顯示圖片
                    this.imageDisplay.displayImage(imageData);

                    // 更新 UI 狀態
                    this.updateUIState(true);
                    this.statusManager.showStatus(this.languageManager.getUIText('imageGenerationSuccess', 'messages'), 'success');

                } catch (error) {
                    Logger.error('生成圖片失敗:', error);
                    this.statusManager.showStatus(error.message, 'error');

                    // 如果生成失敗，隱藏 loading bar 並顯示預設內容
                    this.imageDisplay.hideLoadingBar();
                } finally {
                    // 恢復 UI 狀態
                    this.uiController.setLoadingState(false);
                    // 重新檢查歷史記錄並更新按鈕狀態
                    const hasHistory = await this.imageGenerator.hasHistory();
                    this.updateUIState(hasHistory);
                }
            }

            /**
             * 處理提示詞翻譯
             * @param {string} apiKey - API Key
             * @param {string} prompt - 原始提示詞
             * @returns {Promise<string|null>} 翻譯後的提示詞，如果失敗或取消返回 null
             */
            async handlePromptTranslation(apiKey, prompt) {
                try {
                    // 設定翻譯載入狀態
                    this.uiController.setTranslationLoadingState(true);
                    this.statusManager.showStatus(this.languageManager.getUIText('translatingPrompt', 'messages'), 'loading');

                    if (Utils.isDebugMode()) {
                        console.log('[GeminiImageGenerator] 開始翻譯提示詞:', prompt);
                    }

                    // 調用翻譯服務
                    const translatedPrompt = await PromptTranslator.translateContent(apiKey, prompt, this.languageManager);

                    if (Utils.isDebugMode()) {
                        console.log('[GeminiImageGenerator] 翻譯完成:', translatedPrompt);
                    }

                    return translatedPrompt;

                } catch (error) {
                    Logger.error('提示詞翻譯失敗:', error);
                    const errorMessage = this.languageManager.getUIText('translationFailedWithError', 'messages').replace('{0}', error.message);
                    this.statusManager.showStatus(errorMessage, 'error');
                    return null;
                } finally {
                    // 恢復翻譯狀態
                    this.uiController.setTranslationLoadingState(false);
                }
            }

            /**
             * 處理下載圖片
             */
            handleDownloadImage() {
                try {
                    const imageData = this.imageGenerator.getCurrentImageData();
                    const aspectRatio = this.uiController.getInputValue(CONSTANTS.DOM_IDS.ASPECT_RATIO);

                    if (!imageData) {
                        this.statusManager.showStatus(CONFIG.ERROR_MESSAGES.NO_IMAGE_TO_DOWNLOAD, 'error');
                        return;
                    }

                    DownloadManager.downloadImage(imageData, aspectRatio);
                    this.statusManager.showStatus(this.languageManager.getUIText('downloadSuccess', 'messages'), 'success');

                } catch (error) {
                    Logger.error('下載圖片失敗:', error);
                    this.statusManager.showStatus(error.message, 'error');
                }
            }

            /**
             * 處理清除圖片
             */
            async handleClearImage() {
                try {
                    // 取得當前記錄 ID
                    const currentRecordId = this.imageGenerator.getCurrentRecordId();

                    // 顯示確認對話框
                    const confirmMessage = currentRecordId
                        ? this.languageManager.getUIText('confirmClearImageWithHistory', 'messages')
                        : this.languageManager.getUIText('confirmClearImage', 'messages');

                    if (!confirm(confirmMessage)) {
                        return; // 使用者取消操作
                    }

                    // 檢查當前是否在歷史模式
                    const isInHistoryMode = this.imageDisplay.isGridMode();

                    // 如果有對應的歷史記錄，先從資料庫刪除
                    if (currentRecordId) {
                        await this.imageGenerator.deleteHistoryRecord(currentRecordId);
                        Logger.info(`已從歷史記錄刪除圖片: ${currentRecordId}`);
                    }

                    // 清除圖片顯示
                    this.imageDisplay.clearImage();

                    // 清除圖片資料
                    this.imageGenerator.clearCurrentImage();

                    // 重新檢查歷史記錄狀態
                    const hasHistory = await this.imageGenerator.hasHistory();

                    // 如果當前在歷史模式且刪除了記錄，需要重新載入歷史網格
                    if (isInHistoryMode && currentRecordId) {
                        if (hasHistory) {
                            // 重新載入歷史網格
                            this.currentHistoryOffset = 0;
                            this.hasMoreHistory = true;
                            const records = await this.imageGenerator.loadHistory(0, this.getHistoryPageSize());
                            this.imageDisplay.loadHistoryToGrid(records);

                            // 更新分頁狀態
                            this.currentHistoryOffset = records.length;
                            this.hasMoreHistory = records.length === this.getHistoryPageSize();

                            // 更新載入更多按鈕
                            const gridRenderer = this.imageDisplay.getGridRenderer();
                            if (this.hasMoreHistory) {
                                gridRenderer.showLoadMoreButton();
                            } else {
                                gridRenderer.hideLoadMoreButton();
                            }
                        } else {
                            // 沒有歷史記錄了，退出歷史模式
                            this.hideHistoryGrid();
                        }
                    }

                    // 更新 UI 狀態
                    this.updateUIState(hasHistory);

                    // 顯示成功訊息
                    const successMessage = currentRecordId
                        ? this.languageManager.getUIText('imageClearedWithHistory', 'messages')
                        : this.languageManager.getUIText('imageCleared', 'messages');
                    this.statusManager.showStatus(successMessage, 'info');

                } catch (error) {
                    Logger.error('清除圖片失敗:', error);
                    this.statusManager.showStatus(this.languageManager.getUIText('clearImageError', 'messages'), 'error');
                }
            }

            /**
             * 清理資源
             */
            cleanup() {
                // 清理 resize timeout
                if (this.resizeTimeout) {
                    clearTimeout(this.resizeTimeout);
                    this.resizeTimeout = null;
                }

                this.uiController.cleanup();
                Logger.info('應用程式資源已清理');
            }
        }

        // 當 DOM 載入完成時初始化應用程式
        document.addEventListener('DOMContentLoaded', () => {
            new GeminiImageGenerator();
        });

    </script>
</body>

</html>
